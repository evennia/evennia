
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>evennia.scripts.ondemandhandler &#8212; Evennia latest documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>

     


    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Evennia latest</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../evennia.html" accesskey="U">evennia</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">evennia.scripts.ondemandhandler</a></li> 
      </ul>
    </div>  

    <div class="document">

      <div class="documentwrapper">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/evennia_logo.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><h3>Links</h3>
<ul>
  <li><a href="https://www.evennia.com/docs/latest/index.html">Documentation Top</a> </li>
  <li><a href="https://www.evennia.com">Evennia Home</a> </li>
  <li><a href="https://github.com/evennia/evennia">Github</a> </li>
  <li><a href="http://games.evennia.com">Game Index</a> </li>
  <li>
    <a href="https://discord.gg/AJJpcRUhtF">Discord</a> -
     <a href="https://github.com/evennia/evennia/discussions">Discussions</a> -
      <a href="https://evennia.blogspot.com/">Blog</a>
  </li>
</ul>
<h3>Doc Versions</h3>
<ul>
  
    <li><a href="ondemandhandler.html">latest (main branch)</a></li>

    <li><a href="../4.x/index.html">v4.0.0 branch (outdated)</a></li>
  
    <li><a href="../3.x/index.html">v3.0.0 branch (outdated)</a></li>
  
    <li><a href="../2.x/index.html">v2.0.0 branch (outdated)</a></li>
  
    <li><a href="../1.x/index.html">v1.0.0 branch (outdated)</a></li>
  
    <li><a href="../0.x/index.html">v0.9.5 branch (outdated)</a></li>
  

</ul>

        </div>
      </div>
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for evennia.scripts.ondemandhandler</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Helper to handle on-demand requests, allowing a system to change state only when a player or system</span>
<span class="sd">actually needs the information. This is a very efficient way to handle gradual changes, requiring</span>
<span class="sd">not computer resources until the state is actually needed.</span>

<span class="sd">For example, consider a flowering system, where a seed sprouts, grows and blooms over a certain</span>
<span class="sd">time.  One _could_ implement this with e.g. a Script or a ticker that gradually moves the flower</span>
<span class="sd">along its stages of growth. But what if that flower is in a remote location, and no one is around to</span>
<span class="sd">see it?  You are then wasting computational resources on something that no one is looking at.</span>

<span class="sd">The truth is that most of the time, players are not looking at most of the things in the game. They</span>
<span class="sd">_only_ need to know about which state the flower is in when they are actually looking at it, or</span>
<span class="sd">when they are in the same room as it (so it can be incorporated in the room description). This is</span>
<span class="sd">where on-demand handling comes in.</span>

<span class="sd">This is the basic principle, using the flowering system as an example.</span>

<span class="sd">1. Someone plants a seed in a room (could also be automated). The seed is in a &quot;seedling&quot; state.</span>
<span class="sd">    We store the time it was planted (this is the important bit).</span>
<span class="sd">2. A player enters the room or looks at the plant. We check the time it was planted, and calculate</span>
<span class="sd">  how much time has passed since it was planted. If enough time has passed, we change the state to</span>
<span class="sd">  &quot;sprouting&quot; and probably change its description to reflect this.</span>
<span class="sd">3. If a player looks at the plant and not enough time has passed, it keeps the last updated state.</span>
<span class="sd">4. Eventually, it will be bloom time, and the plant will change to a &quot;blooming&quot; state when the</span>
<span class="sd">   player looks.</span>
<span class="sd">5. If no player ever comes around to look at the plant, it will never change state, and if they show</span>
<span class="sd">   up after a long time, it may not show as a &quot;wilted&quot; state or be outright deleted when observed,</span>
<span class="sd">   since too long time has passed and the plant has died.</span>

<span class="sd">With a system like this you could have growing plants all over your world and computing usage would</span>
<span class="sd">only scale by how many players you have exploring your world. The players will not know the</span>
<span class="sd">difference between this and a system that is always running, but your server will thank you.</span>

<span class="sd">There is only one situation where this system is not ideal, and that is when a player should be</span>
<span class="sd">informed of the state change _even if they perform no action_. That is, even if they are just idling</span>
<span class="sd">in the room, they should get a message like &#39;the plant suddenly blooms&#39; (or, more commonly, for</span>
<span class="sd">messages like &#39;you are feeling hungry&#39;). For this you still probably need to use one of Evennia&#39;s</span>
<span class="sd">built-in timers or tickers instead. But most of the time you should really consider using on-demand</span>
<span class="sd">handling instead.</span>

<span class="sd">## Usage</span>

<span class="sd">```python</span>

<span class="sd">from evennia import ON_DEMAND_HANDLER</span>

<span class="sd"># create a new on-demand task</span>

<span class="sd">flower = create_object(Flower, key=&quot;rose&quot;)</span>

<span class="sd">ON_DEMAND_HANDLER.add_task(</span>
<span class="sd">    flower, category=&quot;flowering&quot;,</span>
<span class="sd">    stages={0: &quot;seedling&quot;, 120: &quot;sprouting&quot;,</span>
<span class="sd">            300: &quot;blooming&quot;, 600: &quot;wilted&quot;, 700: &quot;dead&quot;})</span>

<span class="sd"># later, when we want to check the state of the plant (e.g. in a command),</span>

<span class="sd">state = ON_DEMAND_HANDLER.get_stage(&quot;flowering&quot;, last_checked=plant.planted_time)</span>

<span class="sd">```</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">evennia.server.models</span><span class="w"> </span><span class="kn">import</span> <span class="n">ServerConfig</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">evennia.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">logger</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">evennia.utils.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_iter</span>

<span class="n">_RUNTIME</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">ON_DEMAND_HANDLER</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">ONDEMAND_HANDLER_SAVE_NAME</span> <span class="o">=</span> <span class="s2">&quot;on_demand_timers&quot;</span>


<div class="viewcode-block" id="OnDemandTask"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">OnDemandTask</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stores information about an on-demand task.</span>

<span class="sd">    Default property:</span>
<span class="sd">    - `default_stage_function (callable)`: This is called if no stage function is given in the</span>
<span class="sd">       stages dict.  This is meant for changing the task itself (such as restarting it). Actual</span>
<span class="sd">       game code should be handled elsewhere, by checking this task. See the `stagefunc_*` static</span>
<span class="sd">       methods for examples of how to manipulate the task when a stage is reached.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># useful stage-functions. Use with OnDemandTask.endfunc_stop etc</span>

<div class="viewcode-block" id="OnDemandTask.runtime"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.runtime">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">runtime</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps the gametime.runtime() function.</span>

<span class="sd">        Need to import here to avoid circular imports during server reboot.</span>
<span class="sd">        It&#39;s a callable to allow easier unit testing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">_RUNTIME</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_RUNTIME</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">evennia.utils.gametime</span><span class="w"> </span><span class="kn">import</span> <span class="n">runtime</span> <span class="k">as</span> <span class="n">_RUNTIME</span>
        <span class="k">return</span> <span class="n">_RUNTIME</span><span class="p">()</span></div>

<div class="viewcode-block" id="OnDemandTask.stagefunc_loop"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.stagefunc_loop">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stagefunc_loop</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attach this to the last stage to have the task start over from</span>
<span class="sd">        the beginning</span>

<span class="sd">        Example:</span>
<span class="sd">            stages = {0: &quot;seedling&quot;, 120: &quot;flowering&quot;, 300: &quot;dead&quot;, (&quot;_loop&quot;,</span>
<span class="sd">            OnDemandTask.stagefunc_loop)}</span>

<span class="sd">            Note that the &quot;respawn&quot; state will never actually be visible as a state to</span>
<span class="sd">            the user, instead once it reaches this state, it will *immediately* loop</span>
<span class="sd">            and the new looped state will be shown and returned to the user. So it</span>
<span class="sd">            can an idea to mark that end state with a `_` just to indicate this fact.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">OnDemandTask</span><span class="o">.</span><span class="n">runtime</span><span class="p">()</span>
        <span class="n">original_start_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">task</span><span class="o">.</span><span class="n">start_time</span>
        <span class="p">)</span>  <span class="c1"># this can be set on start or previous call of this func</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">stages</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">total_dt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>

        <span class="c1"># figure out how many times we&#39;ve looped since last start-time was set</span>
        <span class="n">task</span><span class="o">.</span><span class="n">iterations</span> <span class="o">+=</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">original_start_time</span><span class="p">)</span> <span class="o">//</span> <span class="n">total_dt</span>
        <span class="c1"># figure out how far we are into the current loop.</span>
        <span class="n">current_loop_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">original_start_time</span><span class="p">)</span> <span class="o">%</span> <span class="n">total_dt</span>
        <span class="c1"># We need to adjust the start_time to the start of the current loop</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">current_loop_time</span></div>

<div class="viewcode-block" id="OnDemandTask.stagefunc_bounce"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.stagefunc_bounce">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">stagefunc_bounce</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This endfunc will have the task reverse direction and go through the stages in</span>
<span class="sd">        reverse order. This stage-function must be placed at both &#39;ends&#39; of the stage sequence</span>
<span class="sd">        for the bounce to continue indefinitely.</span>

<span class="sd">        Example:</span>
<span class="sd">            stages = {0: (&quot;cool&quot;, OnDemandTask.stagefunc_bounce),</span>
<span class="sd">                      50: &quot;lukewarm&quot;,</span>
<span class="sd">                      150: &quot;warm&quot;,</span>
<span class="sd">                      300: &quot;hot&quot;,</span>
<span class="sd">                      300: (&quot;HOT!&quot;, OnDemandTask.stagefunc_bounce)}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">OnDemandTask</span><span class="o">.</span><span class="n">runtime</span><span class="p">()</span>
        <span class="n">original_start_time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">task</span><span class="o">.</span><span class="n">start_time</span>
        <span class="p">)</span>  <span class="c1"># this can be set on start or previous call of this func</span>
        <span class="n">dts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">stages</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">max_dt</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>
        <span class="n">total_dt</span> <span class="o">=</span> <span class="n">max_dt</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">dts</span><span class="p">)</span>
        <span class="n">task</span><span class="o">.</span><span class="n">iterations</span> <span class="o">+=</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">original_start_time</span><span class="p">)</span> <span class="o">//</span> <span class="n">total_dt</span>
        <span class="n">current_loop_time</span> <span class="o">=</span> <span class="p">(</span><span class="n">now</span> <span class="o">-</span> <span class="n">original_start_time</span><span class="p">)</span> <span class="o">%</span> <span class="n">total_dt</span>
        <span class="n">task</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">current_loop_time</span>

        <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">iterations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># reverse the stages</span>
            <span class="n">stages</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">stages</span>
            <span class="n">task</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="p">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="n">max_dt</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">stages</span><span class="o">.</span><span class="n">items</span><span class="p">())}</span></div>

    <span class="c1"># default fallback stage function. This is called if no stage function is given in the stages</span>
    <span class="c1"># dict.</span>
    <span class="n">default_stage_function</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="OnDemandTask.__init__"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.__init__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">stages</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autostart</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            key (str): A unique identifier for the task.</span>
<span class="sd">            stages (dict, optional): A dictionary `{dt: str}` or `{int or float: (str, callable)}`</span>
<span class="sd">                of time-deltas (in seconds) and the stage name they represent. If the value is a</span>
<span class="sd">                tuple, the first element is the name of the stage and the second is a callable</span>
<span class="sd">                that will be called when that stage is *first* reached. Warning: This callable</span>
<span class="sd">                is *only* triggered if the stage is actually checked/retrieved while the task is</span>
<span class="sd">                in that stage checks - it&#39;s _not_ guaranteed to be called, even if the task</span>
<span class="sd">                time-wise goes through all its stages. Each callable must be picklable (so normally</span>
<span class="sd">                it should be a stand-alone function), and takes one argument - this OnDemandTask,</span>
<span class="sd">                which it can be modified in-place as needed.  This can be used to loop a task or do</span>
<span class="sd">                other changes to the task.</span>
<span class="sd">            autostart (bool, optional): If `last_checked` is `None`, and this is `False`, then the</span>
<span class="sd">                time will not start counting until the first call of `get_dt` or `get_stage`. If</span>
<span class="sd">                `True`, creating the task will immediately make a hidden check and start the timer.</span>

<span class="sd">        Examples:</span>

<span class="sd">           stages = {0: &quot;seedling&quot;,</span>
<span class="sd">                     120: &quot;sprouting&quot;,</span>
<span class="sd">                     300: &quot;blooming&quot;,</span>
<span class="sd">                     600: &quot;wilted&quot;,</span>
<span class="sd">                     700: &quot;dead&quot;</span>
<span class="sd">                    }</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="n">category</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_stage</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterations</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># only used with looping staging functions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stages_by_name</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stages</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># sort the stages by ending time, inserting each state as {dt: (statename, callable)}</span>
            <span class="n">_stages</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">stages</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># validate the input</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Each stage must given as a time-delta in seconds (int or float).&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">is_iter</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Each stage must be a tuple (name, callable) or a name-string.&quot;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The second element of each stage-tuple must be a callable.&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">_stages</span><span class="p">[</span><span class="n">dt</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">stages</span> <span class="o">=</span> <span class="p">{</span><span class="n">dt</span><span class="p">:</span> <span class="n">tup</span> <span class="k">for</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">_stages</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stages_by_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">dt</span> <span class="k">for</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">autostart</span><span class="o">=</span><span class="n">autostart</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Note that we don&#39;t check the state here&quot;&quot;&quot;</span>
        <span class="c1"># we visualize stages with ascending key order</span>
        <span class="n">dt</span><span class="p">,</span> <span class="n">stage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">autostart</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;OnDemandTask(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">category</span><span class="si">}</span><span class="s2">] (dt=</span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s2">s), stage=</span><span class="si">{</span><span class="n">stage</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">OnDemandTask</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">category</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">category</span><span class="p">)</span>

<div class="viewcode-block" id="OnDemandTask.check"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.check">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">autostart</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the current stage of the task and return the time-delta to the next stage.</span>

<span class="sd">        Keyword Args:</span>
<span class="sd">            autostart (bool, optional): If this is set, and the task has not been started yet,</span>
<span class="sd">                it will be started by this check. This is mainly used internally.</span>
<span class="sd">            **kwargs: Will be passed to the stage function, if one is called.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple (dt, stage) where `dt` is the time-delta (in seconds) since the test</span>
<span class="sd">            started (or since it started its latest iteration). and `stage` is the name of the</span>
<span class="sd">            current stage. If no stages are defined, `stage` will always be `None`. Use `get_dt` and</span>
<span class="sd">            `get_stage` to get only one of these values.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_find_stage</span><span class="p">(</span><span class="n">delta_dt</span><span class="p">,</span> <span class="n">_rerun</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">dt</span><span class="p">,</span> <span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">stage_func</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">delta_dt</span> <span class="o">&lt;</span> <span class="n">dt</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">autostart</span> <span class="ow">and</span> <span class="n">stage</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_stage</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_rerun</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">last_stage</span> <span class="o">=</span> <span class="n">stage</span>

                    <span class="k">if</span> <span class="n">stage_func</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">stage_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">log_trace</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Error getting stage of on-demand task </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;(last_stage: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">last_stage</span><span class="si">}</span><span class="s2">, trying to call stage-func &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stage_func</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># rerun the check in case the endfunc changed things</span>
                            <span class="k">return</span> <span class="n">_find_stage</span><span class="p">(</span><span class="n">delta_dt</span><span class="p">,</span> <span class="n">_rerun</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">stage</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_find_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">autostart</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">autostart</span><span class="p">:</span>
                    <span class="c1"># start timer</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">now</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span>
            <span class="k">return</span> <span class="n">dt</span>

        <span class="n">now</span> <span class="o">=</span> <span class="n">OnDemandTask</span><span class="o">.</span><span class="n">runtime</span><span class="p">()</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">_find_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">autostart</span><span class="o">=</span><span class="n">autostart</span><span class="p">)</span>

        <span class="c1"># we must always fetch the stage since a stage_func may fire</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">_find_stage</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># need to fetch dt again in case stage_func changed it</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">_find_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">autostart</span><span class="o">=</span><span class="n">autostart</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dt</span><span class="p">,</span> <span class="n">stage</span></div>

<div class="viewcode-block" id="OnDemandTask.get_dt"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.get_dt">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the time-delta since last check.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: The time since the last check, or 0 if this is the first time the task is checked.</span>
<span class="sd">            **kwargs: Will be passed to the stage function, if one is called.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">autostart</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="OnDemandTask.set_dt"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.set_dt">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the time-delta since the task started manually. This allows you to &#39;cheat&#39; the system</span>
<span class="sd">        and set the time manually. This is useful for testing or when a system manipulates the state</span>
<span class="sd">        somehow (like using a potion that speeds up the growth of a plant).</span>

<span class="sd">        Args:</span>
<span class="sd">            dt (int): The time-delta to set. This is an absolute value in seconds, same as returned</span>
<span class="sd">                by `get_dt`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Setting this will not on its own trigger any stage functions - this will only happen</span>
<span class="sd">            as normal, next time the state is checked and the stage is found to have changed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">OnDemandTask</span><span class="o">.</span><span class="n">runtime</span><span class="p">()</span> <span class="o">-</span> <span class="n">dt</span></div>

<div class="viewcode-block" id="OnDemandTask.get_stage"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.get_stage">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_stage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the current stage of the task. If no stage was given, this will return `None` but</span>
<span class="sd">        still update the last_checked time.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str or None: The current stage of the task, or `None` if no stages are set.</span>
<span class="sd">            **kwargs: Will be passed to the stage function, if one is called.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">autostart</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="OnDemandTask.set_stage"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandTask.set_stage">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_stage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the stage of the task manually. This allows you to &#39;cheat&#39; the system and set the stage</span>
<span class="sd">        manually. This is useful for testing or when a system manipulates the state somehow (like</span>
<span class="sd">        using a potion that speeds up the growth of a plant). The given stage must be previously</span>
<span class="sd">        created for the given task. If task has no stages, this will do nothing.</span>

<span class="sd">        Args:</span>
<span class="sd">            stage (str, optional): The stage to set. If `None`, the task will be reset to its</span>
<span class="sd">                initial (first) state.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Setting this will not on its own trigger any stage functions - this will only happen</span>
<span class="sd">            as normal, next time the state is checked and the stage is found to have changed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">stage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">OnDemandTask</span><span class="o">.</span><span class="n">runtime</span><span class="p">()</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stages</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">stage</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages_by_name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">OnDemandTask</span><span class="o">.</span><span class="n">runtime</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">stages_by_name</span><span class="p">[</span><span class="n">stage</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="OnDemandHandler"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler">[docs]</a><span class="k">class</span><span class="w"> </span><span class="nc">OnDemandHandler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A singleton handler for managing on-demand state changes. Its main function is to persistently</span>
<span class="sd">    track the time (in seconds) between a state change and the next. How you make use of this</span>
<span class="sd">    information is up to your particular system.</span>

<span class="sd">    Contrary to just using the `time` module, this will also account for server restarts.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="OnDemandHandler.__init__"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.__init__">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span></div>

<div class="viewcode-block" id="OnDemandHandler.load"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.load">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the on-demand timers from ServerConfig storage.</span>

<span class="sd">        This should be automatically called when Evennia starts.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ServerConfig</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">conf</span><span class="p">(</span><span class="n">ONDEMAND_HANDLER_SAVE_NAME</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="nb">dict</span><span class="p">))</span></div>

<div class="viewcode-block" id="OnDemandHandler.save"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.save">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the on-demand timers to ServerConfig storage. Should be called when Evennia shuts down.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="c1"># in case an object was used for categories, and were since deleted, drop the task</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">category</span><span class="o">.</span><span class="n">id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">pop</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">))</span>
        <span class="n">ServerConfig</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">conf</span><span class="p">(</span><span class="n">ONDEMAND_HANDLER_SAVE_NAME</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">)</span></div>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a unique key for the task.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str, callable, OnDemandTask or Object): The task key. If callable, it will be</span>
<span class="sd">                called without arguments. If an Object, will be converted to a string. If</span>
<span class="sd">                an `OnDemandTask`, then all other arguments are ignored and the task will be used</span>
<span class="sd">                to build the internal storage key.</span>
<span class="sd">            category (str or callable): The task category. If callable, it will be called without</span>
<span class="sd">                arguments.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple (str, str or None): The unique key.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">OnDemandTask</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">category</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">()</span> <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">else</span> <span class="n">key</span><span class="p">),</span>
            <span class="n">category</span><span class="p">()</span> <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">category</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">category</span><span class="p">)</span> <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="OnDemandHandler.add"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.add">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stages</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autostart</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a new on-demand task.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str, callable, OnDemandTask or Object): A unique identifier for the task. If this</span>
<span class="sd">                is a callable, it will be called without arguments. If a db-Object, it will be</span>
<span class="sd">                converted to a string representation (which will include its (#dbref). If an</span>
<span class="sd">                `OnDemandTask`, then all other arguments are ignored and the task is simply added</span>
<span class="sd">                as-is.</span>
<span class="sd">            category (str or callable, optional): A category to group the task under. If given, it</span>
<span class="sd">                must also be given when checking the task.</span>
<span class="sd">            stages (dict, optional): A dictionary {dt: str}, of time-deltas (in seconds) and the</span>
<span class="sd">                stage which should be entered after that much time has passed.  autostart (bool,</span>
<span class="sd">            optional): If `True`, creating the task will immediately make a hidden</span>
<span class="sd">                check and start the timer.</span>

<span class="sd">        Returns:</span>
<span class="sd">            OnDemandTask: The created task (or the same that was added, if given an `OnDemandTask`</span>
<span class="sd">                as a `key`).  Use `task.get_dt()` and `task.get_stage()` to get data from it</span>
<span class="sd">                manually.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">OnDemandTask</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_key</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">category</span><span class="p">)]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">OnDemandTask</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">stages</span><span class="p">,</span> <span class="n">autostart</span><span class="o">=</span><span class="n">autostart</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">)]</span> <span class="o">=</span> <span class="n">task</span>
        <span class="k">return</span> <span class="n">task</span></div>

<div class="viewcode-block" id="OnDemandHandler.batch_add"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.batch_add">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">batch_add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tasks</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add multiple on-demand tasks at once.</span>

<span class="sd">        Args:</span>
<span class="sd">            *tasks (OnDemandTask): A set of OnDemandTasks to add.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_key</span><span class="p">(</span><span class="n">task</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="o">.</span><span class="n">category</span><span class="p">)]</span> <span class="o">=</span> <span class="n">task</span></div>

<div class="viewcode-block" id="OnDemandHandler.remove"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.remove">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove an on-demand task.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str, callable, OnDemandTask or Object): The unique identifier for the task. If a</span>
<span class="sd">                callable, will be called without arguments. If an Object, will be converted to a</span>
<span class="sd">                string.  If an `OnDemandTask`, then all other arguments are ignored and the task</span>
<span class="sd">                will be used to identify the task to remove.</span>
<span class="sd">            category (str or callable, optional): The category of the task.</span>

<span class="sd">        Returns:</span>
<span class="sd">            OnDemandTask or None: The removed task, or `None` if no task was found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="OnDemandHandler.batch_remove"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.batch_remove">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">batch_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove multiple on-demand tasks at once, potentially within a given category.</span>

<span class="sd">        Args:</span>
<span class="sd">            *keys (str, callable, OnDemandTask or Object): The unique identifiers for the tasks. If</span>
<span class="sd">                a callable, will be called without arguments. If an Object, will be converted to a</span>
<span class="sd">                string. If an `OnDemandTask`, then all other arguments are ignored and the task will</span>
<span class="sd">                be used to identify the task to remove.</span>
<span class="sd">            category (str or callable, optional): The category of the tasks.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">)</span></div>

<div class="viewcode-block" id="OnDemandHandler.all"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.all">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_on_none</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all on-demand tasks.</span>

<span class="sd">        Args:</span>
<span class="sd">            category (str, optional): The category of the tasks.</span>
<span class="sd">            all_on_none (bool, optional): Determines what to return if `category` is `None`.</span>
<span class="sd">                If `True`, all tasks will be returned. If `False`, only tasks without a category</span>
<span class="sd">                will be returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: A dictionary of all on-demand task, on the form `{(key, category): task), ...}`.</span>
<span class="sd">            Use `task.get_dt()` or `task.get_stage()` to get the time-delta or stage of each task</span>
<span class="sd">            manually.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">all_on_none</span><span class="p">:</span>
            <span class="c1"># return all</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span>

        <span class="c1"># filter by category (treat no-category as its own category)</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">keytuple</span><span class="p">:</span> <span class="n">task</span> <span class="k">for</span> <span class="n">keytuple</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">keytuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">category</span><span class="p">}</span></div>

<div class="viewcode-block" id="OnDemandHandler.clear"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.clear">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_on_none</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear all on-demand tasks.</span>

<span class="sd">        Args:</span>
<span class="sd">            category (str, optional): The category of the tasks to clear. What `None` means is</span>
<span class="sd">                determined by the `all_on_none` kwarg.</span>
<span class="sd">            all_on_none (bool, optional): Determines what to clear if `category` is `None`. If</span>
<span class="sd">                `True`, clear all tasks, if `False`, only clear tasks with no category.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">all_on_none</span><span class="p">:</span>
            <span class="c1"># clear all</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># filter and clear only those matching the category</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">keytuple</span><span class="p">:</span> <span class="n">task</span> <span class="k">for</span> <span class="n">keytuple</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">keytuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">category</span>
        <span class="p">}</span></div>

<div class="viewcode-block" id="OnDemandHandler.get"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.get">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an on-demand task. This will _not_ check it.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str, callable, OnDemandTask or Object): The unique identifier for the task. If a</span>
<span class="sd">                callable, will be called without arguments. If an Object, will be converted to a</span>
<span class="sd">                string.  If an `OnDemandTask`, then all other arguments are ignored and the task</span>
<span class="sd">                will be used (only useful to check the task is the same).</span>

<span class="sd">            category (str, optional): The category of the task. If unset, this will only return</span>
<span class="sd">                tasks with no category.</span>

<span class="sd">        Returns:</span>
<span class="sd">            OnDemandTask or None: The task, or `None` if no task was found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tasks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_build_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">))</span></div>

<div class="viewcode-block" id="OnDemandHandler.get_dt"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.get_dt">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the time-delta since the task started.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str, callable, OnDemandTask or Object): The unique identifier for the task. If a</span>
<span class="sd">                callable, will be called without arguments. If an Object, will be converted to a</span>
<span class="sd">                string.  If an `OnDemandTask`, then all other arguments are ignored and the task</span>
<span class="sd">                will be used to identify the task to get the time-delta from.</span>
<span class="sd">            **kwargs: Will be passed to the stage function, if one is called.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int or None: The time since the last check, or `None` if no task was found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">get_dt</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">task</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="OnDemandHandler.set_dt"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.set_dt">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the time-delta since the task started manually. This allows you to &#39;cheat&#39; the system</span>
<span class="sd">        and set the time manually. This is useful for testing or when a system manipulates the state</span>
<span class="sd">        somehow (like using a potion that speeds up the growth of a plant).</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str, callable, OnDemandTask or Object): The unique identifier for the task. If a</span>
<span class="sd">                callable, will be called without arguments. If an Object, will be converted to a</span>
<span class="sd">                string. If an `OnDemandTask`, then all other arguments are ignored and the task will</span>
<span class="sd">                be used to identify the task to set the time-delta for.</span>
<span class="sd">            category (str, optional): The category of the task.</span>
<span class="sd">            dt (int): The time-delta to set. This is an absolute value in seconds, same as returned</span>
<span class="sd">                by `get_dt`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Setting this will not on its own trigger any stage functions - this will only happen</span>
<span class="sd">            as normal, next time the state is checked and the stage is found to have changed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_dt</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span></div>

<div class="viewcode-block" id="OnDemandHandler.get_stage"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.get_stage">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">get_stage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the current stage of an on-demand task.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str, callable, OnDemandTask or Object): The unique identifier for the task. If a</span>
<span class="sd">                callable, will be called without arguments. If an Object, will be converted to a</span>
<span class="sd">                string.  If an `OnDemandTask`, then all other arguments are ignored and the task</span>
<span class="sd">                will be used to identify the task to get the stage from.</span>
<span class="sd">            category (str, optional): The category of the task.</span>
<span class="sd">            **kwargs: Will be passed to the stage function, if one is called.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str or None: The current stage of the task, or `None` if no task was found.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">task</span><span class="o">.</span><span class="n">get_stage</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">task</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="OnDemandHandler.set_stage"><a class="viewcode-back" href="../../../api/evennia.scripts.ondemandhandler.html#evennia.scripts.ondemandhandler.OnDemandHandler.set_stage">[docs]</a>    <span class="k">def</span><span class="w"> </span><span class="nf">set_stage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the stage of an on-demand task manually. This allows you to &#39;cheat&#39; the system and set</span>
<span class="sd">        the stage manually. This is useful for testing or when a system manipulates the state</span>
<span class="sd">        somehow (like using a potion that speeds up the growth of a plant). The given stage must</span>
<span class="sd">        be previously created for the given task. If task has no stages, this will do nothing.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str, callable, OnDemandTask or Object): The unique identifier for the task. If a</span>
<span class="sd">                callable, will be called without arguments. If an Object, will be converted to a</span>
<span class="sd">                string.  If an `OnDemandTask`, then all other arguments are ignored and the task</span>
<span class="sd">                will be used to identify the task to set the stage for.</span>
<span class="sd">            category (str, optional): The category of the task.</span>
<span class="sd">            stage (str, optional): The stage to set. If `None`, the task will be reset to its</span>
<span class="sd">                initial (first) state.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Setting this will not on its own trigger any stage functions - this will only happen</span>
<span class="sd">            as normal, next time the state is checked and the stage is found to have changed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">task</span><span class="p">:</span>
            <span class="n">task</span><span class="o">.</span><span class="n">set_stage</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span></div></div>


<span class="c1"># Create singleton</span>
<span class="n">ON_DEMAND_HANDLER</span> <span class="o">=</span> <span class="n">OnDemandHandler</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>

    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Evennia latest</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../evennia.html" >evennia</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">evennia.scripts.ondemandhandler</a></li> 
      </ul>
    </div>

     

    <div class="footer" role="contentinfo">
        &#169; Copyright 2024, The Evennia developer community.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>