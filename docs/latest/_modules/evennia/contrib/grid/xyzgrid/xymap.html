<!DOCTYPE html>

<html lang="en" data-content_root="../../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>evennia.contrib.grid.xyzgrid.xymap &#8212; Evennia latest documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=d75fae25" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/nature.css?v=279e0f84" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/custom.css?v=e4a91a55" />
    <script src="../../../../../_static/documentation_options.js?v=c6e86fd7"></script>
    <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">Evennia</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../../evennia.html" accesskey="U">evennia</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">evennia.contrib.grid.xyzgrid.xymap</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for evennia.contrib.grid.xyzgrid.xymap</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"># XYMap</span>

<span class="sd">The `XYMap` class represents one XY-grid of interconnected map-legend components. It&#39;s built from an</span>
<span class="sd">ASCII representation, where unique characters represents each type of component. The Map parses the</span>
<span class="sd">map into an internal graph that can be efficiently used for pathfinding the shortest route between</span>
<span class="sd">any two nodes (rooms).</span>

<span class="sd">Each room (MapNode) can have exits (links) in 8 cardinal directions (north, northwest etc) as well</span>
<span class="sd">as up and down. These are indicated in code as &#39;n&#39;, &#39;ne&#39;, &#39;e&#39;, &#39;se&#39;, &#39;s&#39;, &#39;sw&#39;, &#39;w&#39;,</span>
<span class="sd">&#39;nw&#39;, &#39;u&#39; and &#39;d&#39;.</span>


<span class="sd">```python</span>
<span class="sd">    # in module passed to &#39;Map&#39; class</span>

<span class="sd">    MAP = r&#39;&#39;&#39;</span>
<span class="sd">                           1</span>
<span class="sd">     + 0 1 2 3 4 5 6 7 8 9 0</span>

<span class="sd">    10 #   # # #     #-I-#</span>
<span class="sd">        \  i i i     d</span>
<span class="sd">     9   #-#-#-#     |</span>
<span class="sd">         |\    |     u</span>
<span class="sd">     8   #-#-#-#-----#b----o</span>
<span class="sd">         |     |           |</span>
<span class="sd">     7   #-#---#-#-#-#-#   |</span>
<span class="sd">         |         |x|x|   |</span>
<span class="sd">     6   o-#-#-#   #-#-#-#b#</span>
<span class="sd">            \      |x|x|</span>
<span class="sd">     5   o---#-#&lt;--#-#-#</span>
<span class="sd">        /    |</span>
<span class="sd">     4 #-----+-# #---#</span>
<span class="sd">        \    | |  \ /</span>
<span class="sd">     3   #b#-#-#   x   #</span>
<span class="sd">             | |  / \ u</span>
<span class="sd">     2       #-#-#---#</span>
<span class="sd">             ^       d</span>
<span class="sd">     1       #-#     #</span>
<span class="sd">             |</span>
<span class="sd">     0 #-#---o</span>

<span class="sd">     + 0 1 2 3 4 5 6 7 8 9 1</span>
<span class="sd">                           0</span>

<span class="sd">    &#39;&#39;&#39;</span>


<span class="sd">    LEGEND = {&#39;#&#39;: xyzgrid.MapNode, &#39;|&#39;: xyzgrid.NSMapLink,...}</span>

<span class="sd">    # read by parser if XYMAP_DATA_LIST doesn&#39;t exist</span>
<span class="sd">    XYMAP_DATA = {</span>
<span class="sd">        &quot;map&quot;: MAP,</span>
<span class="sd">        &quot;legend&quot;: LEGEND,</span>
<span class="sd">        &quot;zcoord&quot;: &quot;City of Foo&quot;,</span>
<span class="sd">        &quot;prototypes&quot;: {</span>
<span class="sd">            (0,1): { ... },</span>
<span class="sd">            (1,3): { ... },</span>
<span class="sd">            ...</span>
<span class="sd">        }</span>

<span class="sd">    }</span>

<span class="sd">    # will be parsed first, allows for multiple map-data dicts from one module</span>
<span class="sd">    XYMAP_DATA_LIST = [</span>
<span class="sd">        XYMAP_DATA</span>
<span class="sd">    ]</span>

<span class="sd">```</span>

<span class="sd">The two `+` signs  in the upper/lower left corners are required and marks the edge of the map area.</span>
<span class="sd">The origo of the grid is always two steps right and two up from the bottom test marker and the grid</span>
<span class="sd">extends to two lines below the top-left marker. Anything outside the grid is ignored, so numbering</span>
<span class="sd">the coordinate axes is optional but recommended for readability.</span>

<span class="sd">The XY positions represent coordinates positions in the game world. When existing, they are usually</span>
<span class="sd">represented by Rooms in-game. The links between nodes would normally represent Exits, but the length</span>
<span class="sd">of links on the map have no in-game equivalence except that traversing a multi-step link will place</span>
<span class="sd">you in a location with an XY coordinate different from what you&#39;d expect by a single step (most</span>
<span class="sd">games don&#39;t relay the XY position to the player anyway).</span>

<span class="sd">In the map string, every XY coordinate must have exactly one spare space/line between them - this is</span>
<span class="sd">used for node linkings. This finer grid which has 2x resolution of the `XYgrid` is only used by the</span>
<span class="sd">mapper and is referred to as the `xygrid` (small xy) internally. Note that an XY position can also</span>
<span class="sd">be held by a link (for example a passthrough).</span>

<span class="sd">The nodes and links can be customized by add your own implementation of `MapNode` or `MapLink` to</span>
<span class="sd">the LEGEND dict, mapping them to a particular character symbol. A `MapNode` can only be added</span>
<span class="sd">on an even XY coordinate while `MapLink`s can be added anywhere on the xygrid.</span>

<span class="sd">See `./example.py` for a full grid example.</span>

<span class="sd">----</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os</span><span class="w"> </span><span class="kn">import</span> <span class="n">mkdir</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os.path</span><span class="w"> </span><span class="kn">import</span> <span class="n">isdir</span><span class="p">,</span> <span class="n">isfile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os.path</span><span class="w"> </span><span class="kn">import</span> <span class="n">join</span> <span class="k">as</span> <span class="n">pathjoin</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">zeros</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">csr_matrix</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse.csgraph</span><span class="w"> </span><span class="kn">import</span> <span class="n">dijkstra</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="se">\n</span><span class="s2">The XYZgrid contrib requires &quot;</span>
        <span class="s2">&quot;the SciPy package. Install with `pip install scipy&#39;.&quot;</span>
    <span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">django.conf</span><span class="w"> </span><span class="kn">import</span> <span class="n">settings</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">evennia.prototypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">prototypes</span> <span class="k">as</span> <span class="n">protlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">evennia.prototypes.spawner</span><span class="w"> </span><span class="kn">import</span> <span class="n">flatten_prototype</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">evennia.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">logger</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">evennia.utils.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_iter</span><span class="p">,</span> <span class="n">mod_import</span><span class="p">,</span> <span class="n">variable_from_module</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">xymap_legend</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">BIGVAL</span><span class="p">,</span> <span class="n">MapError</span><span class="p">,</span> <span class="n">MapParserError</span>

<span class="n">_NO_DB_PROTOTYPES</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="s2">&quot;XYZGRID_USE_DB_PROTOTYPES&quot;</span><span class="p">):</span>
    <span class="n">_NO_DB_PROTOTYPES</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">settings</span><span class="o">.</span><span class="n">XYZGRID_USE_DB_PROTOTYPES</span>

<span class="n">_CACHE_DIR</span> <span class="o">=</span> <span class="n">settings</span><span class="o">.</span><span class="n">CACHE_DIR</span>
<span class="n">_LOADED_PROTOTYPES</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_XYZROOMCLASS</span> <span class="o">=</span> <span class="kc">None</span>

<span class="n">MAP_DATA_KEYS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;zcoord&quot;</span><span class="p">,</span> <span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="s2">&quot;legend&quot;</span><span class="p">,</span> <span class="s2">&quot;prototypes&quot;</span><span class="p">,</span> <span class="s2">&quot;options&quot;</span><span class="p">,</span> <span class="s2">&quot;module_path&quot;</span><span class="p">]</span>

<span class="n">DEFAULT_LEGEND</span> <span class="o">=</span> <span class="n">xymap_legend</span><span class="o">.</span><span class="n">LEGEND</span>

<span class="c1"># --------------------------------------------</span>
<span class="c1"># Map parser implementation</span>


<div class="viewcode-block" id="XYMap">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">XYMap</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This represents a single map of interconnected nodes/rooms, parsed from a ASCII map</span>
<span class="sd">    representation.</span>

<span class="sd">    Each room is connected to each other as a directed graph with optional &#39;weights&#39; between the the</span>
<span class="sd">    connections. It is created from a map string with symbols describing the topological layout. It</span>
<span class="sd">    also provides pathfinding using the Dijkstra algorithm.</span>

<span class="sd">    The map-string is read from a string or from a module.  The grid area of the string is marked by</span>
<span class="sd">    two `+` characters - one in the top left of the area and the other in the bottom left.</span>
<span class="sd">    The grid starts two spaces/lines in from the &#39;open box&#39; created by these two markers and extend</span>
<span class="sd">    any width to the right.</span>
<span class="sd">    Any other markers or comments can be added outside of the grid - they will be ignored.  Every</span>
<span class="sd">    grid coordinate must always be separated by exactly one space/line since the space between</span>
<span class="sd">    are used for links.</span>
<span class="sd">    ::</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="sd">                               1 1 1</span>
<span class="sd">         + 0 1 2 3 4 5 6 7 8 9 0 1 2 ...</span>

<span class="sd">         4       #         #   #</span>
<span class="sd">                 |          \ /</span>
<span class="sd">         3     #-#-#     #   #</span>
<span class="sd">               |          \ /</span>
<span class="sd">         2     #-#-#       #</span>
<span class="sd">               |x|x|       |</span>
<span class="sd">         1     #-#-#-#-#-#-#</span>
<span class="sd">              /</span>
<span class="sd">         0 #-#</span>

<span class="sd">         + 0 1 2 3 4 5 6 7 8 9 1 1 1 ...</span>
<span class="sd">                               0 1 2</span>
<span class="sd">        &#39;&#39;&#39;</span>

<span class="sd">    So origo (0,0) is in the bottom-left and north is +y movement, south is -y movement</span>
<span class="sd">    while east/west is +/- x movement as expected. Adding numbers to axes is optional</span>
<span class="sd">    but recommended for readability!</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mapcorner_symbol</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
    <span class="n">max_pathfinding_length</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="n">empty_symbol</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
    <span class="c1"># we normally only accept one single character for the legend key</span>
    <span class="n">legend_key_exceptions</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="XYMap.__init__">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_module_or_dict</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="n">xyzgrid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the map parser by feeding it the map.</span>

<span class="sd">        Args:</span>
<span class="sd">            map_module_or_dict (str, module or dict): Path or module pointing to a map. If a dict,</span>
<span class="sd">                this should be a dict with a MAP_DATA key &#39;map&#39; and optionally a &#39;legend&#39;</span>
<span class="sd">                dicts to specify the map structure.</span>
<span class="sd">            Z (int or str, optional): Name or Z-coord for for this map. Needed if the game uses</span>
<span class="sd">                more than one map. If not given, it can also be embedded in the</span>
<span class="sd">                `map_module_or_dict`. Used when referencing this map during map transitions,</span>
<span class="sd">                baking of pathfinding matrices etc.</span>
<span class="sd">            xyzgrid (.xyzgrid.XYZgrid): A top-level grid this map is a part of.</span>

<span class="sd">        Notes:</span>
<span class="sd">            Interally, the map deals with two sets of coordinate systems:</span>
<span class="sd">            - grid-coordinates x,y are the character positions in the map string.</span>
<span class="sd">            - world-coordinates X,Y are the in-world coordinates of nodes/rooms.</span>
<span class="sd">              There are fewer of these since they ignore the &#39;link&#39; spaces between</span>
<span class="sd">              the nodes in the grid, s</span>

<span class="sd">                  X = x // 2</span>
<span class="sd">                  Y = y // 2</span>

<span class="sd">            - The Z-coordinate, if given, is only used when transitioning between maps</span>
<span class="sd">              on the supplied `grid`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">_LOADED_PROTOTYPES</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_LOADED_PROTOTYPES</span><span class="p">:</span>
            <span class="c1"># inject default prototypes, but don&#39;t override prototype-keys loaded from</span>
            <span class="c1"># settings, if they exist (that means the user wants to replace the defaults)</span>
            <span class="n">protlib</span><span class="o">.</span><span class="n">load_module_prototypes</span><span class="p">(</span>
                <span class="s2">&quot;evennia.contrib.grid.xyzgrid.prototypes&quot;</span><span class="p">,</span> <span class="n">override</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">_LOADED_PROTOTYPES</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Z</span> <span class="o">=</span> <span class="n">Z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzgrid</span> <span class="o">=</span> <span class="n">xyzgrid</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mapstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_mapstring</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># store so we can reload</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map_module_or_dict</span> <span class="o">=</span> <span class="n">map_module_or_dict</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">prototypes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># transitional mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_map</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># map setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xygrid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">XYgrid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_X</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_Y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Dijkstra algorithm variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pathfinding_routes</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pathfinder_baked_filename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">Z</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">isdir</span><span class="p">(</span><span class="n">_CACHE_DIR</span><span class="p">):</span>
                <span class="n">mkdir</span><span class="p">(</span><span class="n">_CACHE_DIR</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pathfinder_baked_filename</span> <span class="o">=</span> <span class="n">pathjoin</span><span class="p">(</span><span class="n">_CACHE_DIR</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Z</span><span class="si">}</span><span class="s2">.P&quot;</span><span class="p">)</span>

        <span class="c1"># load data and parse it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reload</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the string representation of the map.</span>
<span class="sd">        Since the y-axes origo is at the bottom, we must flip the</span>
<span class="sd">        y-axis before printing (since printing is always top-to-bottom).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_map</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nnodes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span><span class="p">:</span>
            <span class="n">nnodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;XYMap(Z=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="si">}</span><span class="s2">), </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_Y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">nnodes</span><span class="si">}</span><span class="s2"> nodes&gt;&quot;</span>

<div class="viewcode-block" id="XYMap.log">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.log">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzgrid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzgrid</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">log_info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="XYMap.reload">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.reload">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_module_or_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (Re)Load a map.</span>

<span class="sd">        Args:</span>
<span class="sd">            map_module_or_dict (str, module or dict, optional): See description for the variable</span>
<span class="sd">                in the class&#39; `__init__` function. If given, replace the already loaded</span>
<span class="sd">                map with a new one. If not given, the existing one given on class creation</span>
<span class="sd">                will be reloaded.</span>
<span class="sd">            parse (bool, optional): If set, auto-run `.parse()` on the newly loaded data.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This will both (re)load the data and parse it into a new map structure, replacing any</span>
<span class="sd">            existing one. The valid mapstructure is:</span>
<span class="sd">            ::</span>

<span class="sd">                {</span>
<span class="sd">                    &quot;map&quot;: &lt;str&gt;,</span>
<span class="sd">                    &quot;zcoord&quot;: &lt;int or str&gt;, # optional</span>
<span class="sd">                    &quot;legend&quot;: &lt;dict&gt;,       # optional</span>
<span class="sd">                    &quot;prototypes&quot;: &lt;dict&gt;    # optional</span>
<span class="sd">                    &quot;options&quot;: &lt;dict&gt;       # optional</span>
<span class="sd">                }</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">map_module_or_dict</span><span class="p">:</span>
            <span class="n">map_module_or_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">map_module_or_dict</span>

        <span class="n">mapdata</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">map_module_or_dict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># map-structure provided directly</span>
            <span class="n">mapdata</span> <span class="o">=</span> <span class="n">map_module_or_dict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># read from contents of module</span>
            <span class="n">mod</span> <span class="o">=</span> <span class="n">mod_import</span><span class="p">(</span><span class="n">map_module_or_dict</span><span class="p">)</span>
            <span class="n">mapdata_list</span> <span class="o">=</span> <span class="n">variable_from_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="s2">&quot;XYMAP_DATA_LIST&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mapdata_list</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="p">:</span>
                <span class="c1"># use the stored Z value to figure out which map data we want</span>
                <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">mapdata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zcoord&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">mapdata</span> <span class="ow">in</span> <span class="n">mapdata_list</span><span class="p">}</span>
                <span class="n">mapdata</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="p">{})</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">mapdata</span><span class="p">:</span>
                <span class="n">mapdata</span> <span class="o">=</span> <span class="n">variable_from_module</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="s2">&quot;XYMAP_DATA&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">mapdata</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MapError</span><span class="p">(</span>
                <span class="s2">&quot;No valid XYMAP_DATA or XYMAP_DATA_LIST could be found from &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">map_module_or_dict</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># validate</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mapdata</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">MAP_DATA_KEYS</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MapError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Mapdata has keys </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">mapdata</span><span class="p">)</span><span class="si">}</span><span class="s2">, but only &quot;</span> <span class="sa">f</span><span class="s2">&quot;keys </span><span class="si">{</span><span class="n">MAP_DATA_KEYS</span><span class="si">}</span><span class="s2"> are allowed.&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mapdata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;legend&quot;</span><span class="p">,</span> <span class="n">DEFAULT_LEGEND</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legend_key_exceptions</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">MapError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Map-legend key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; is invalid: All keys must &quot;</span>
                        <span class="s2">&quot;be exactly one character long. Use the node/link&#39;s &quot;</span>
                        <span class="s2">&quot;`.display_symbol` property to change how it is &quot;</span>
                        <span class="s2">&quot;displayed.&quot;</span>
                    <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;map&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mapdata</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mapdata</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">MapError</span><span class="p">(</span><span class="s2">&quot;No map found. Add &#39;map&#39; key to map-data dict.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">prototype</span> <span class="ow">in</span> <span class="n">mapdata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;prototypes&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">is_iter</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">MapError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Prototype override key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> is malformed: It must be a &quot;</span>
                    <span class="s2">&quot;coordinate (X, Y) for nodes or (X, Y, direction) for links; &quot;</span>
                    <span class="s2">&quot;where direction is a supported direction string (&#39;n&#39;, &#39;ne&#39;, etc).&quot;</span>
                <span class="p">)</span>

        <span class="c1"># store/update result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Z</span> <span class="o">=</span> <span class="n">mapdata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zcoord&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapstring</span> <span class="o">=</span> <span class="n">mapdata</span><span class="p">[</span><span class="s2">&quot;map&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prototypes</span> <span class="o">=</span> <span class="n">mapdata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;prototypes&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">mapdata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;options&quot;</span><span class="p">,</span> <span class="p">{})</span>

        <span class="c1"># merge the custom legend onto the default legend to allow easily</span>
        <span class="c1"># overriding only parts of it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">DEFAULT_LEGEND</span><span class="p">,</span> <span class="o">**</span><span class="n">map_module_or_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;legend&quot;</span><span class="p">,</span> <span class="n">DEFAULT_LEGEND</span><span class="p">)}</span>

        <span class="c1"># initialize any prototypes on the legend entities</span>
        <span class="k">for</span> <span class="n">char</span><span class="p">,</span> <span class="n">node_or_link_class</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">prototype</span> <span class="o">=</span> <span class="n">node_or_link_class</span><span class="o">.</span><span class="n">prototype</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prototype</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># nothing more to do</span>
                <span class="k">continue</span>
            <span class="c1"># we need to load the prototype dict onto each for ease of access. Note that</span>
            <span class="n">proto</span> <span class="o">=</span> <span class="n">protlib</span><span class="o">.</span><span class="n">search_prototype</span><span class="p">(</span>
                <span class="n">prototype</span><span class="p">,</span> <span class="n">require_single</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">no_db</span><span class="o">=</span><span class="n">_NO_DB_PROTOTYPES</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">node_or_link_class</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="n">proto</span></div>


<div class="viewcode-block" id="XYMap.parse">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.parse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses the numerical grid from the string. The first pass means parsing out</span>
<span class="sd">        all nodes. The linking-together of nodes is not happening until the second pass</span>
<span class="sd">        (the reason for this is that maps can also link to other maps, so all maps need</span>
<span class="sd">        to have gone through their first parsing-passes before they can be linked together).</span>

<span class="sd">        See the class docstring for details of how the grid should be defined.</span>

<span class="sd">        Notes:</span>
<span class="sd">            In this parsing, the &#39;xygrid&#39; is the full range of chraracters read from</span>
<span class="sd">            the string. The `XYgrid` is used to denote the game-world coordinates</span>
<span class="sd">            (which doesn&#39;t include the links)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mapcorner_symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapcorner_symbol</span>
        <span class="c1"># this allows for string-based [x][y] mapping with arbitrary objects</span>
        <span class="n">xygrid</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="c1"># mapping nodes to real X,Y positions</span>
        <span class="n">XYgrid</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="c1"># needed by pathfinder</span>
        <span class="n">node_index_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># used by transitions</span>
        <span class="n">symbol_map</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="n">mapstring</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapstring</span>
        <span class="k">if</span> <span class="n">mapstring</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">mapcorner_symbol</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MapParserError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The mapstring must have at least two &#39;</span><span class="si">{</span><span class="n">mapcorner_symbol</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;symbols marking the upper- and bottom-left corners of the &quot;</span>
                <span class="s2">&quot;grid area.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># find the the position (in the string as a whole) of the top-left corner-marker</span>
        <span class="n">maplines</span> <span class="o">=</span> <span class="n">mapstring</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">topleft_marker_x</span><span class="p">,</span> <span class="n">topleft_marker_y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">topleft_marker_y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">maplines</span><span class="p">):</span>
            <span class="n">topleft_marker_x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">mapcorner_symbol</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">topleft_marker_x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="p">(</span><span class="n">topleft_marker_x</span><span class="p">,</span> <span class="n">topleft_marker_y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MapParserError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No top-left corner-marker (</span><span class="si">{</span><span class="n">mapcorner_symbol</span><span class="si">}</span><span class="s2">) found!&quot;</span><span class="p">)</span>

        <span class="c1"># find the position (in the string as a whole) of the bottom-left corner-marker</span>
        <span class="c1"># this is always in a stright line down from the first marker</span>
        <span class="n">botleft_marker_x</span><span class="p">,</span> <span class="n">botleft_marker_y</span> <span class="o">=</span> <span class="n">topleft_marker_x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">botleft_marker_y</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">maplines</span><span class="p">[</span><span class="n">topleft_marker_y</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]):</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">mapcorner_symbol</span><span class="p">)</span> <span class="o">==</span> <span class="n">topleft_marker_x</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">botleft_marker_y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MapParserError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No bottom-left corner-marker (</span><span class="si">{</span><span class="n">mapcorner_symbol</span><span class="si">}</span><span class="s2">) found! &quot;</span>
                <span class="s2">&quot;Make sure it lines up with the top-left corner-marker &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(found at column </span><span class="si">{</span><span class="n">topleft_marker_x</span><span class="si">}</span><span class="s2"> of the string).&quot;</span>
            <span class="p">)</span>
        <span class="c1"># the actual coordinate is dy below the topleft marker so we need to shift</span>
        <span class="n">botleft_marker_y</span> <span class="o">+=</span> <span class="n">topleft_marker_y</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># in-string_position of the top- and bottom-left grid corners (2 steps in from marker)</span>
        <span class="c1"># the bottom-left corner is also the origo (0,0) of the grid.</span>
        <span class="n">topleft_y</span> <span class="o">=</span> <span class="n">topleft_marker_y</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">origo_x</span><span class="p">,</span> <span class="n">origo_y</span> <span class="o">=</span> <span class="n">botleft_marker_x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">botleft_marker_y</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># highest actually filled grid points</span>
        <span class="n">max_x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_X</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_Y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">node_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># first pass: read string-grid (left-right, bottom-up) and parse all grid points</span>
        <span class="k">for</span> <span class="n">iy</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">maplines</span><span class="p">[</span><span class="n">topleft_y</span><span class="p">:</span><span class="n">origo_y</span><span class="p">])):</span>
            <span class="n">even_iy</span> <span class="o">=</span> <span class="n">iy</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">origo_x</span><span class="p">:]):</span>
                <span class="c1"># from now on, coordinates are on the xygrid.</span>

                <span class="k">if</span> <span class="n">char</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_symbol</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># only set this if there&#39;s actually something on the line</span>
                <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_x</span><span class="p">,</span> <span class="n">ix</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_y</span><span class="p">,</span> <span class="n">iy</span><span class="p">)</span>

                <span class="n">mapnode_or_link_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">mapnode_or_link_class</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">MapParserError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Symbol &#39;</span><span class="si">{</span><span class="n">char</span><span class="si">}</span><span class="s2">&#39; on XY=(</span><span class="si">{</span><span class="n">ix</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">iy</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">) &quot;</span> <span class="s2">&quot;is not found in LEGEND.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mapnode_or_link_class</span><span class="p">,</span> <span class="s2">&quot;node_index&quot;</span><span class="p">):</span>
                    <span class="c1"># A mapnode. Mapnodes can only be placed on even grid positions, where</span>
                    <span class="c1"># there are integer X,Y coordinates defined.</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">even_iy</span> <span class="ow">and</span> <span class="n">ix</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">MapParserError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Symbol &#39;</span><span class="si">{</span><span class="n">char</span><span class="si">}</span><span class="s2">&#39; on XY=(</span><span class="si">{</span><span class="n">ix</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">iy</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="si">:</span><span class="s2">g</span><span class="si">}</span><span class="s2">) marks a &quot;</span>
                            <span class="s2">&quot;MapNode but is located between integer (X,Y) positions (only &quot;</span>
                            <span class="s2">&quot;Links can be placed between coordinates)!&quot;</span>
                        <span class="p">)</span>

                    <span class="c1"># save the node to several different maps for different uses</span>
                    <span class="c1"># in both coordinate systems</span>
                    <span class="n">iX</span><span class="p">,</span> <span class="n">iY</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">iy</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="n">max_X</span><span class="p">,</span> <span class="n">max_Y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_X</span><span class="p">,</span> <span class="n">iX</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_Y</span><span class="p">,</span> <span class="n">iY</span><span class="p">)</span>
                    <span class="n">node_index</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="n">xygrid</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">XYgrid</span><span class="p">[</span><span class="n">iX</span><span class="p">][</span><span class="n">iY</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_index_map</span><span class="p">[</span><span class="n">node_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">mapnode_or_link_class</span><span class="p">(</span>
                            <span class="n">x</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">iy</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">node_index</span><span class="o">=</span><span class="n">node_index</span><span class="p">,</span> <span class="n">symbol</span><span class="o">=</span><span class="n">char</span><span class="p">,</span> <span class="n">xymap</span><span class="o">=</span><span class="bp">self</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># we have a link at this xygrid position (this is ok everywhere)</span>
                    <span class="n">xygrid</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapnode_or_link_class</span><span class="p">(</span>
                        <span class="n">x</span><span class="o">=</span><span class="n">ix</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">iy</span><span class="p">,</span> <span class="n">Z</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">symbol</span><span class="o">=</span><span class="n">char</span><span class="p">,</span> <span class="n">xymap</span><span class="o">=</span><span class="bp">self</span>
                    <span class="p">)</span>

                <span class="c1"># store the symbol mapping for transition lookups</span>
                <span class="n">symbol_map</span><span class="p">[</span><span class="n">char</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xygrid</span><span class="p">[</span><span class="n">ix</span><span class="p">][</span><span class="n">iy</span><span class="p">])</span>

        <span class="c1"># store before building links</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_y</span> <span class="o">=</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_Y</span> <span class="o">=</span> <span class="n">max_X</span><span class="p">,</span> <span class="n">max_Y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xygrid</span> <span class="o">=</span> <span class="n">xygrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">XYgrid</span> <span class="o">=</span> <span class="n">XYgrid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span> <span class="o">=</span> <span class="n">node_index_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_map</span> <span class="o">=</span> <span class="n">symbol_map</span>

        <span class="c1"># build all links</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_index_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">node</span><span class="o">.</span><span class="n">build_links</span><span class="p">()</span>

        <span class="c1"># build display map</span>
        <span class="n">display_map</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot; &quot;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">ydct</span> <span class="ow">in</span> <span class="n">xygrid</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">iy</span><span class="p">,</span> <span class="n">node_or_link</span> <span class="ow">in</span> <span class="n">ydct</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">display_map</span><span class="p">[</span><span class="n">iy</span><span class="p">][</span><span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_or_link</span><span class="o">.</span><span class="n">get_display_symbol</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_index_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># override node-prototypes, ignore if no prototype</span>
            <span class="c1"># is defined (some nodes should not be spawned)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">prototype</span><span class="p">:</span>
                <span class="n">node_coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
                <span class="c1"># load prototype from override, or use default</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="n">flatten_prototype</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">prototypes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                            <span class="n">node_coord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">prototypes</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">),</span> <span class="n">node</span><span class="o">.</span><span class="n">prototype</span><span class="p">)</span>
                        <span class="p">),</span>
                        <span class="n">no_db</span><span class="o">=</span><span class="n">_NO_DB_PROTOTYPES</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">MapParserError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Room prototype malformed: </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="c1"># do the same for links (x, y, direction) coords</span>
                <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="n">maplink</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">first_links</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">maplink</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="n">flatten_prototype</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">prototypes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                <span class="n">node_coord</span> <span class="o">+</span> <span class="p">(</span><span class="n">direction</span><span class="p">,),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">prototypes</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">),</span> <span class="n">maplink</span><span class="o">.</span><span class="n">prototype</span><span class="p">),</span>
                            <span class="p">),</span>
                            <span class="n">no_db</span><span class="o">=</span><span class="n">_NO_DB_PROTOTYPES</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">MapParserError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exit prototype malformed: </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">maplink</span><span class="p">)</span>

        <span class="c1"># store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_map</span> <span class="o">=</span> <span class="n">display_map</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_topology_around_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all links and nodes up to a certain distance from an XY coordinate.</span>

<span class="sd">        Args:</span>
<span class="sd">            xy (tuple), the X,Y coordinate of the center point.</span>
<span class="sd">            dist (int): How many nodes away from center point to find paths for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple of 5 elements `(xy_coords, xmin, xmax, ymin, ymax)`, where the</span>
<span class="sd">                first element is a list of xy-coordinates (on xygrid) for all linked nodes within</span>
<span class="sd">                range. This is meant to be used with the xygrid for extracting a subset</span>
<span class="sd">                for display purposes. The others are the minimum size of the rectangle</span>
<span class="sd">                surrounding the area containing `xy_coords`.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This performs a depth-first pass down the the given dist.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_scan_neighbors</span><span class="p">(</span>
            <span class="n">start_node</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="n">BIGVAL</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="n">BIGVAL</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">start_node</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">start_node</span><span class="o">.</span><span class="n">y</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">))</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">x0</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">depth</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                <span class="c1"># keep stepping</span>
                <span class="k">for</span> <span class="n">direction</span><span class="p">,</span> <span class="n">end_node</span> <span class="ow">in</span> <span class="n">start_node</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span>
                    <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">start_node</span><span class="o">.</span><span class="n">xy_steps_to_node</span><span class="p">[</span><span class="n">direction</span><span class="p">]:</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">link</span><span class="o">.</span><span class="n">y</span>
                        <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

                    <span class="n">points</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">_scan_neighbors</span><span class="p">(</span>
                        <span class="n">end_node</span><span class="p">,</span>
                        <span class="n">points</span><span class="p">,</span>
                        <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">,</span>
                        <span class="n">xmin</span><span class="o">=</span><span class="n">xmin</span><span class="p">,</span>
                        <span class="n">ymin</span><span class="o">=</span><span class="n">ymin</span><span class="p">,</span>
                        <span class="n">xmax</span><span class="o">=</span><span class="n">xmax</span><span class="p">,</span>
                        <span class="n">ymax</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span>
                        <span class="n">depth</span><span class="o">=</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">return</span> <span class="n">points</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span>

        <span class="n">center_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_coord</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
        <span class="n">points</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">_scan_neighbors</span><span class="p">(</span><span class="n">center_node</span><span class="p">,</span> <span class="p">[],</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">points</span><span class="p">)),</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span>

<div class="viewcode-block" id="XYMap.calculate_path_matrix">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.calculate_path_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate_path_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the pathfinding problem using Dijkstra&#39;s algorithm. This will try to</span>
<span class="sd">        load the solution from disk if possible.</span>

<span class="sd">        Args:</span>
<span class="sd">            force (bool, optional): If the cache should always be rebuilt.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathfinder_baked_filename</span> <span class="ow">and</span> <span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathfinder_baked_filename</span><span class="p">):</span>
            <span class="c1"># check if the solution for this grid was already solved previously.</span>

            <span class="n">mapstr</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">,</span> <span class="n">pathfinding_routes</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathfinder_baked_filename</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fil</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mapstr</span><span class="p">,</span> <span class="n">dist_matrix</span><span class="p">,</span> <span class="n">pathfinding_routes</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fil</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">log_trace</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">mapstr</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapstring</span>
                <span class="ow">and</span> <span class="n">dist_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">pathfinding_routes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="c1"># this is important - it means the map hasn&#39;t changed so</span>
                <span class="c1"># we can re-use the stored data!</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">dist_matrix</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pathfinding_routes</span> <span class="o">=</span> <span class="n">pathfinding_routes</span>

        <span class="c1"># build a matrix representing the map graph, with 0s as impassable areas</span>

        <span class="n">nnodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span><span class="p">)</span>
        <span class="n">pathfinding_graph</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">nnodes</span><span class="p">,</span> <span class="n">nnodes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">inode</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">pathfinding_graph</span><span class="p">[</span><span class="n">inode</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">linkweights</span><span class="p">(</span><span class="n">nnodes</span><span class="p">)</span>

        <span class="c1"># create a sparse matrix to represent link relationships from each node</span>
        <span class="n">pathfinding_matrix</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">pathfinding_graph</span><span class="p">)</span>

        <span class="c1"># solve using Dijkstra&#39;s algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathfinding_routes</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="p">(</span>
            <span class="n">pathfinding_matrix</span><span class="p">,</span>
            <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">return_predecessors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_pathfinding_length</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathfinder_baked_filename</span><span class="p">:</span>
            <span class="c1"># try to cache the results</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathfinder_baked_filename</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fil</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapstring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathfinding_routes</span><span class="p">),</span> <span class="n">fil</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">4</span>
                <span class="p">)</span></div>


<div class="viewcode-block" id="XYMap.spawn_nodes">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.spawn_nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spawn_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the nodes of this XYMap into actual in-world rooms by spawning their</span>
<span class="sd">        related prototypes in the correct coordinate positions. This must be done *first*</span>
<span class="sd">        before spawning links (with `spawn_links` because exits require the target destination</span>
<span class="sd">        to exist. It&#39;s also possible to only spawn a subset of the map</span>

<span class="sd">        Args:</span>
<span class="sd">            xy (tuple, optional): An (X,Y) coordinate of node(s). `&#39;*&#39;` acts as a wildcard.</span>

<span class="sd">        Examples:</span>
<span class="sd">            - `xy=(1, 3) - spawn (1,3) coordinate only.</span>
<span class="sd">            - `xy=(&#39;*&#39;, 1) - spawn all nodes in the first row of the map only.</span>
<span class="sd">            - `xy=(&#39;*&#39;, &#39;*&#39;)` - spawn all nodes</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of nodes that were spawned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">global</span> <span class="n">_XYZROOMCLASS</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_XYZROOMCLASS</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">evennia.contrib.grid.xyzgrid.xyzroom</span><span class="w"> </span><span class="kn">import</span> <span class="n">XYZRoom</span> <span class="k">as</span> <span class="n">_XYZROOMCLASS</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="n">wildcard</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>
        <span class="n">spawned</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># find existing nodes, in case some rooms need to be removed</span>
        <span class="n">map_coords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Y</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">X</span><span class="p">))</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">existing_room</span> <span class="ow">in</span> <span class="n">_XYZROOMCLASS</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter_xyz</span><span class="p">(</span><span class="n">xyz</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Z</span><span class="p">)):</span>
            <span class="n">roomX</span><span class="p">,</span> <span class="n">roomY</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">existing_room</span><span class="o">.</span><span class="n">xyz</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">roomX</span><span class="p">,</span> <span class="n">roomY</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">map_coords</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  deleting room at </span><span class="si">{</span><span class="n">existing_room</span><span class="o">.</span><span class="n">xyz</span><span class="si">}</span><span class="s2"> (not found on map).&quot;</span><span class="p">)</span>
                <span class="n">existing_room</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

        <span class="c1"># (re)build nodes (will not build already existing rooms)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">X</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wildcard</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">X</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wildcard</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Y</span><span class="p">)):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">spawn</span><span class="p">()</span>
                <span class="n">spawned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spawned</span></div>


<div class="viewcode-block" id="XYMap.spawn_links">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.spawn_links">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spawn_links</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">),</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert links of this XYMap into actual in-game exits by spawning their related</span>
<span class="sd">        prototypes. It&#39;s possible to only spawn a specic exit by specifying the node and</span>

<span class="sd">        Args:</span>
<span class="sd">            xy (tuple, optional): An (X,Y) coordinate of node(s). `&#39;*&#39;` acts as a wildcard.</span>
<span class="sd">            nodes (list, optional): If given, only consider links out of these nodes. This also</span>
<span class="sd">                affects `xy`, so that if there are no nodes of given coords in `nodes`, no</span>
<span class="sd">                links will be spawned at all.</span>
<span class="sd">            directions (list, optional): A list of cardinal directions (&#39;n&#39;, &#39;ne&#39; etc). If given,</span>
<span class="sd">                sync only the exit in the given directions (`xy` limits which links out of which</span>
<span class="sd">                nodes should be considered). If unset, there are no limits to directions.</span>
<span class="sd">        Examples:</span>
<span class="sd">            - `xy=(1, 3 )`, `direction=&#39;ne&#39;` - sync only the north-eastern exit</span>
<span class="sd">                out of the (1, 3) node.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="n">wildcard</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">X</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wildcard</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">X</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="ow">in</span> <span class="p">(</span><span class="n">wildcard</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">Y</span><span class="p">)):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">spawn_links</span><span class="p">(</span><span class="n">directions</span><span class="o">=</span><span class="n">directions</span><span class="p">)</span></div>


<div class="viewcode-block" id="XYMap.get_node_from_coord">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.get_node_from_coord">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_node_from_coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a MapNode from a coordinate.</span>

<span class="sd">        Args:</span>
<span class="sd">            xy (tuple): X,Y coordinate on XYgrid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            MapNode: The node found at the given coordinates. Returns</span>
<span class="sd">                `None` if there is no mapnode at the given coordinate.</span>

<span class="sd">        Raises:</span>
<span class="sd">            MapError: If trying to specify an iX,iY outside</span>
<span class="sd">                of the grid&#39;s maximum bounds.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">XYgrid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>

        <span class="n">iX</span><span class="p">,</span> <span class="n">iY</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iX</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_X</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">iY</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_Y</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">MapError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;get_node_from_coord got coordinate </span><span class="si">{</span><span class="n">xy</span><span class="si">}</span><span class="s2"> which is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;outside the grid size of (0,0) - (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_X</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_Y</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">XYgrid</span><span class="p">[</span><span class="n">iX</span><span class="p">][</span><span class="n">iY</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="XYMap.get_components_with_symbol">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.get_components_with_symbol">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_components_with_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find all map components (nodes, links) with a given symbol in this map.</span>

<span class="sd">        Args:</span>
<span class="sd">            symbol (char): A single character-symbol to search for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: A list of MapNodes and/or MapLinks found with the matching symbol.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="p">[])</span></div>


<div class="viewcode-block" id="XYMap.get_shortest_path">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.get_shortest_path">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_xy</span><span class="p">,</span> <span class="n">end_xy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the shortest route between two points on the grid.</span>

<span class="sd">        Args:</span>
<span class="sd">            start_xy (tuple): A starting (X,Y) coordinate on the XYgrid (in-game coordinate) for</span>
<span class="sd">                where we start from.</span>
<span class="sd">            end_xy (tuple or MapNode): The end (X,Y) coordinate on the XYgrid (in-game coordinate)</span>
<span class="sd">                we want to find the shortest route to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: Two lists, first containing the list of directions as strings (n, ne etc) and</span>
<span class="sd">            the second is a mixed list of MapNodes and all MapLinks in a sequence describing</span>
<span class="sd">            the full path including the start- and end-node.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_coord</span><span class="p">(</span><span class="n">start_xy</span><span class="p">)</span>
        <span class="n">endnode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_coord</span><span class="p">(</span><span class="n">end_xy</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">startnode</span> <span class="ow">and</span> <span class="n">endnode</span><span class="p">):</span>
            <span class="c1"># no node at given coordinate. No path is possible.</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="p">[]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">istartnode</span> <span class="o">=</span> <span class="n">startnode</span><span class="o">.</span><span class="n">node_index</span>
            <span class="n">inextnode</span> <span class="o">=</span> <span class="n">endnode</span><span class="o">.</span><span class="n">node_index</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MapError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Map.get_shortest_path received start/end nodes </span><span class="si">{</span><span class="n">startnode</span><span class="si">}</span><span class="s2"> and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">endnode</span><span class="si">}</span><span class="s2">. They must both be MapNodes (not Links)&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathfinding_routes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate_path_matrix</span><span class="p">()</span>

        <span class="n">pathfinding_routes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathfinding_routes</span>
        <span class="n">node_index_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_index_map</span>

        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">endnode</span><span class="p">]</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">pathfinding_routes</span><span class="p">[</span><span class="n">istartnode</span><span class="p">,</span> <span class="n">inextnode</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">9999</span><span class="p">:</span>
            <span class="c1"># the -9999 is set by algorithm for unreachable nodes or if trying</span>
            <span class="c1"># to go a node we are already at (the start node in this case since</span>
            <span class="c1"># we are working backwards).</span>
            <span class="n">inextnode</span> <span class="o">=</span> <span class="n">pathfinding_routes</span><span class="p">[</span><span class="n">istartnode</span><span class="p">,</span> <span class="n">inextnode</span><span class="p">]</span>
            <span class="n">nextnode</span> <span class="o">=</span> <span class="n">node_index_map</span><span class="p">[</span><span class="n">inextnode</span><span class="p">]</span>
            <span class="n">shortest_route_to</span> <span class="o">=</span> <span class="n">nextnode</span><span class="o">.</span><span class="n">shortest_route_to_node</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">node_index</span><span class="p">]</span>

            <span class="n">directions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shortest_route_to</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">path</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shortest_route_to</span><span class="p">[</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">nextnode</span><span class="p">])</span>

        <span class="c1"># we have the path - reverse to get the correct order</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">directions</span><span class="p">,</span> <span class="n">path</span></div>


<div class="viewcode-block" id="XYMap.get_visual_range">
<a class="viewcode-back" href="../../../../../api/evennia.contrib.grid.xyzgrid.xymap.html#evennia.contrib.grid.xyzgrid.xymap.XYMap.get_visual_range">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_visual_range</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xy</span><span class="p">,</span>
        <span class="n">dist</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span>
        <span class="n">character</span><span class="o">=</span><span class="s2">&quot;@&quot;</span><span class="p">,</span>
        <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">target_path_style</span><span class="o">=</span><span class="s2">&quot;|y</span><span class="si">{display_symbol}</span><span class="s2">|n&quot;</span><span class="p">,</span>
        <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">return_str</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a part of the grid centered on a specific point and extended a certain number</span>
<span class="sd">        of nodes or grid points in every direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            xy (tuple): (X,Y) in-world coordinate location. If this is not the location</span>
<span class="sd">                of a node on the grid, the `character` or the empty-space symbol (by default</span>
<span class="sd">                an empty space) will be shown.</span>
<span class="sd">            dist (int, optional): Number of gridpoints distance to show. Which</span>
<span class="sd">                grid to use depends on the setting of `only_nodes`. Set to `None` to</span>
<span class="sd">                always show the entire grid.</span>
<span class="sd">            mode (str, optional): One of &#39;scan&#39; or &#39;nodes&#39;. In &#39;scan&#39; mode, dist measure</span>
<span class="sd">                number of xy grid points in all directions and doesn&#39;t care about if visible</span>
<span class="sd">                nodes are reachable or not. If &#39;nodes&#39;, distance measure how many linked nodes</span>
<span class="sd">                away from the center coordinate to display.</span>
<span class="sd">            character (str, optional): Place this symbol at the `xy` position</span>
<span class="sd">                of the displayed map. The center node&#39;s symbol is shown if this is falsy.</span>
<span class="sd">            target (tuple, optional): A target XY coordinate to go to. The path to this</span>
<span class="sd">                (or the beginning of said path, if outside of visual range) will be</span>
<span class="sd">                marked according to `target_path_style`.</span>
<span class="sd">            target_path_style (str or callable, optional): This is use for marking the path</span>
<span class="sd">                found when `target` is given. If a string, it accepts a formatting marker</span>
<span class="sd">                `display_symbol` which will be filled with the `display_symbol` of each node/link</span>
<span class="sd">                the path passes through. This allows e.g. to color the path. If a callable, this</span>
<span class="sd">                will receive the MapNode or MapLink object for every step of the path and and</span>
<span class="sd">                must return the suitable string to display at the position of the node/link.</span>
<span class="sd">            max_size (tuple, optional): A max `(width, height)` to crop the displayed</span>
<span class="sd">                return to. Make both odd numbers to get a perfect center. Set either of</span>
<span class="sd">                the tuple values to `None` to make that coordinate unlimited. Set entire</span>
<span class="sd">                tuple to None let display-size able to grow up to full size of grid.</span>
<span class="sd">            indent (int, optional): How far to the right to indent the map area (only</span>
<span class="sd">                applies to `return_str=True`).</span>
<span class="sd">            return_str (bool, optional): Return result as an already formatted string</span>
<span class="sd">                or a 2D list.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str or list: Depending on value of `return_str`. If a list,</span>
<span class="sd">                this is 2D grid of lines, [[str,str,str,...], [...]] where</span>
<span class="sd">                each element is a single character in the display grid. To</span>
<span class="sd">                extract a character at (ix,iy) coordinate from it, use</span>
<span class="sd">                indexing `outlist[iy][ix]` in that order.</span>

<span class="sd">        Notes:</span>
<span class="sd">            If outputting a list, the y-axis must first be reversed before printing since printing</span>
<span class="sd">            happens top-bottom and the y coordinate system goes bottom-up. This can be done simply</span>
<span class="sd">            with this before building the final string to send/print.</span>

<span class="sd">                printable_order_list = outlist[::-1]</span>

<span class="sd">            If mode=&#39;nodes&#39;, a `dist` of 2 will give the following result in a row of nodes:</span>

<span class="sd">               #-#-@----------#-#</span>

<span class="sd">            This display may thus visually grow much bigger than expected (both horizontally and</span>
<span class="sd">            vertically). consider setting `max_size` if wanting to restrict the display size. Also</span>
<span class="sd">            note that link &#39;weights&#39; are *included* in this estimate, so if links have weights &gt; 1,</span>
<span class="sd">            fewer nodes may be found for a given `dist`.</span>

<span class="sd">            If mode=`scan`, a dist of 2 on the above example would instead give</span>

<span class="sd">                #-@--</span>

<span class="sd">            This mode simply shows a cut-out subsection of the map you are on. The `dist` is</span>
<span class="sd">            measured on xygrid, so two steps per XY coordinate. It does not consider links or</span>
<span class="sd">            weights and may also show nodes not actually reachable at the moment:</span>

<span class="sd">                | |</span>
<span class="sd">                # @-#</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iX</span><span class="p">,</span> <span class="n">iY</span> <span class="o">=</span> <span class="n">xy</span>
        <span class="c1"># convert inputs to xygrid</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_y</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">iX</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="p">)),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">iY</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
        <span class="n">display_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_map</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">height</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">dist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># show the entire grid</span>
            <span class="n">gridmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_map</span>
            <span class="n">ixc</span><span class="p">,</span> <span class="n">iyc</span> <span class="o">=</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span>

        <span class="k">elif</span> <span class="n">dist</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_coord</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
            <span class="c1"># There is no node at these coordinates. Show</span>
            <span class="c1"># nothing but ourselves or emptiness</span>
            <span class="k">return</span> <span class="n">character</span> <span class="k">if</span> <span class="n">character</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty_symbol</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span>
            <span class="c1"># dist measures only full, reachable nodes.</span>
            <span class="n">points</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_topology_around_coord</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>

            <span class="n">ixc</span><span class="p">,</span> <span class="n">iyc</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="n">ymin</span>
            <span class="c1"># note - override width/height here since our grid is</span>
            <span class="c1"># now different from the original for future cropping</span>
            <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">gridmap</span> <span class="o">=</span> <span class="p">[[</span><span class="s2">&quot; &quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">width</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ix0</span><span class="p">,</span> <span class="n">iy0</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
                <span class="n">gridmap</span><span class="p">[</span><span class="n">iy0</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">][</span><span class="n">ix0</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">]</span> <span class="o">=</span> <span class="n">display_map</span><span class="p">[</span><span class="n">iy0</span><span class="p">][</span><span class="n">ix0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;scan&quot;</span><span class="p">:</span>
            <span class="c1"># scan-mode - dist measures individual grid points</span>

            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ix</span> <span class="o">-</span> <span class="n">dist</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">ix</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="n">dist</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">iy</span> <span class="o">+</span> <span class="n">dist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ixc</span><span class="p">,</span> <span class="n">iyc</span> <span class="o">=</span> <span class="n">ix</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">iy</span> <span class="o">-</span> <span class="n">ymin</span>
            <span class="n">gridmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">display_map</span><span class="p">[</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MapError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Map.get_visual_range &#39;mode&#39; was &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;- it must be either &#39;scan&#39; or &#39;nodes&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">character</span><span class="p">:</span>
            <span class="n">gridmap</span><span class="p">[</span><span class="n">iyc</span><span class="p">][</span><span class="n">ixc</span><span class="p">]</span> <span class="o">=</span> <span class="n">character</span>  <span class="c1"># correct indexing; it&#39;s a list of lines</span>

        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="c1"># stylize path to target</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_default_callable</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">target_path_style</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">display_symbol</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">get_display_symbol</span><span class="p">())</span>

            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">target_path_style</span><span class="p">):</span>
                <span class="n">_target_path_style</span> <span class="o">=</span> <span class="n">target_path_style</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_target_path_style</span> <span class="o">=</span> <span class="n">_default_callable</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shortest_path</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

            <span class="n">maxstep</span> <span class="o">=</span> <span class="n">dist</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span> <span class="k">else</span> <span class="n">dist</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">nsteps</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">node_or_link</span> <span class="ow">in</span> <span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node_or_link</span><span class="p">,</span> <span class="s2">&quot;node_index&quot;</span><span class="p">):</span>
                    <span class="n">nsteps</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">nsteps</span> <span class="o">&gt;</span> <span class="n">maxstep</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="c1"># don&#39;t decorate current (character?) location</span>
                <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">node_or_link</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">node_or_link</span><span class="o">.</span><span class="n">y</span>
                <span class="k">if</span> <span class="n">xmin</span> <span class="o">&lt;=</span> <span class="n">ix</span> <span class="o">&lt;=</span> <span class="n">xmax</span> <span class="ow">and</span> <span class="n">ymin</span> <span class="o">&lt;=</span> <span class="n">iy</span> <span class="o">&lt;=</span> <span class="n">ymax</span><span class="p">:</span>
                    <span class="n">gridmap</span><span class="p">[</span><span class="n">iy</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">][</span><span class="n">ix</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">]</span> <span class="o">=</span> <span class="n">_target_path_style</span><span class="p">(</span><span class="n">node_or_link</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">max_size</span><span class="p">:</span>
            <span class="c1"># crop grid to make sure it doesn&#39;t grow too far</span>
            <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">max_size</span>
            <span class="n">max_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_x</span> <span class="k">if</span> <span class="n">max_x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">max_x</span>
            <span class="n">max_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_y</span> <span class="k">if</span> <span class="n">max_y</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">max_y</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ixc</span> <span class="o">-</span> <span class="n">max_x</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">ixc</span> <span class="o">+</span> <span class="n">max_x</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iyc</span> <span class="o">-</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">iyc</span> <span class="o">+</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">gridmap</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">gridmap</span><span class="p">[</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">return_str</span><span class="p">:</span>
            <span class="c1"># we must flip the y-axis before returning the string</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="n">indent</span> <span class="o">*</span> <span class="s2">&quot; &quot;</span>
            <span class="k">return</span> <span class="n">indent</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">indent</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">gridmap</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">gridmap</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../../../index.html">
              <img class="logo" src="../../../../../_static/evennia_logo.png" alt="Logo of Evennia"/>
            </a></p>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Links</h3>
<ul>
  <li><a href="https://www.evennia.com/docs/latest/index.html">Documentation Top</a> </li>
  <li><a href="https://www.evennia.com">Evennia Home</a> </li>
  <li><a href="https://github.com/evennia/evennia">Github</a> </li>
  <li><a href="http://games.evennia.com">Game Index</a> </li>
  <li>
    <a href="https://discord.gg/AJJpcRUhtF">Discord</a> -
     <a href="https://github.com/evennia/evennia/discussions">Discussions</a> -
      <a href="https://evennia.blogspot.com/">Blog</a>
  </li>
</ul>
<h3>Doc Versions</h3>
<ul>
  
    <li>
      <a href="https://www.evennia.com/docs/latest/index.html">latest (main branch)</a>
    </li>
  
  
    <li>
      <a href="https://www.evennia.com/docs/5.x/index.html">v5.0.0 branch (outdated)</a>
    </li>
  
    <li>
      <a href="https://www.evennia.com/docs/4.x/index.html">v4.0.0 branch (outdated)</a>
    </li>
  
    <li>
      <a href="https://www.evennia.com/docs/3.x/index.html">v3.0.0 branch (outdated)</a>
    </li>
  
    <li>
      <a href="https://www.evennia.com/docs/2.x/index.html">v2.0.0 branch (outdated)</a>
    </li>
  
    <li>
      <a href="https://www.evennia.com/docs/1.x/index.html">v1.0.0 branch (outdated)</a>
    </li>
  
    <li>
      <a href="https://www.evennia.com/docs/0.x/index.html">v0.9.5 branch (outdated)</a>
    </li>
  
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">Evennia</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" >Module code</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../../../evennia.html" >evennia</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">evennia.contrib.grid.xyzgrid.xymap</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, The Evennia developer community.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    </div>
  </body>
</html>