# 使用事件的语音操控电梯

本教程将引导您使用[游戏内 Python 系统](./Contrib-Ingame-Python.md)创建一个语音操控的电梯。本教程假设已根据该文档中的说明安装了游戏内 Python 系统。**您不需要阅读**完整文档，它是一个很好的参考，但不是学习它的最佳方式，因此有这些教程。

游戏内 Python 系统允许在某些情况下在单个对象上运行代码。安装完成后，您无需修改源代码即可添加这些功能。整个系统使得为某些对象添加特定功能变得容易，但不是所有对象。

> 我们将尝试做什么？

在本教程中，我们将创建一个简单的语音操控电梯。就功能而言，我们将：

- 探索带有参数的事件。
- 处理更有趣的回调。
- 学习链式事件。
- 在回调中玩转变量修改。

## 我们的研究案例

首先总结一下我们想要实现的目标。我们想创建一个房间来代表电梯的内部。在这个房间里，角色可以简单地说“1”、“2”或“3”，电梯就会开始移动。门将在新楼层打开和关闭（进出电梯的出口将被修改）。

我们将首先处理基本功能，然后进行调整，向您展示如何通过游戏内 Python 系统轻松且强大地配置独立动作。

## 创建我们需要的房间和出口

我们将在我们的房间（通常称为“Limbo”，ID 为 2）中创建一个电梯。当然，如果您已经有一些房间和出口，您可以轻松地调整以下说明，只需记住检查 ID。

> 注意：游戏内 Python 系统在很多地方使用 ID。虽然不是强制性的，但知道您为回调设置的 ID 是一个好习惯，因为它会使操作更快。还有其他方法可以识别对象，但由于它们依赖于许多因素，ID 通常是我们回调中最安全的路径。

让我们进入 Limbo（`#2`）以添加我们的电梯。我们会将其添加到北边。要创建此房间，您可以在游戏中输入：

    tunnel n = Inside of an elevator

游戏应该会告诉您：

    Created room Inside of an elevator(#3) of type typeclasses.rooms.Room.
    Created Exit from Limbo to Inside of an elevator: north(#4) (n).
    Created Exit back from Inside of an elevator to Limbo: south(#5) (s).

注意给定的 ID：

- `#2` 是 Limbo，系统创建的第一个房间。
- `#3` 是我们电梯内部的房间。
- `#4` 是从 Limbo 到我们电梯的北出口。
- `#5` 是从电梯到 Limbo 的南出口。

将这些 ID 保存在某处以供演示。您很快会看到它们为何重要。

> 我们为什么要创建通往电梯的出口并返回 Limbo？电梯不是应该移动吗？

是的。但我们需要有代表进入电梯和出去的出口。我们将在每一层更改这些出口，以便它们连接到正确的房间。您稍后会看到这个过程。

我们还有两个房间要创建：我们的第二层和第三层。这次我们将使用 `dig`，因为我们不需要通往那里的出口，至少目前不需要。

    dig The second floor
    dig The third floor

Evennia 应该会回答：

    Created room The second floor(#6) of type typeclasses.rooms.Room.
    Created room The third floor(#7) of type typeclasses.rooms.Room.

将这些 ID 添加到您的列表中，我们也将使用它们。

## 我们在电梯中的第一个回调

让我们去电梯（如果您有与我相同的 ID，可以使用 `tel #3`）。

这是我们的电梯房间。看起来有点空，您可以随意添加更漂亮的描述或其他装饰。

但我们现在想要的是能够说“1”、“2”或“3”，让电梯朝那个方向移动。

如果您阅读了[关于在事件中添加对话的游戏内 Python 教程](./Contrib-Ingame-Python-Tutorial-Dialogue.md)，您可能还记得我们需要做什么。如果没有，这里是一个总结：我们需要在有人在房间里说话时运行一些代码。因此，我们需要创建一个回调（回调将包含我们的代码行）。我们只需要知道在哪个事件上设置它。您可以输入 `call here` 查看此房间中的可能事件。

在表格中，您应该看到“say”事件，当有人在房间里说话时被调用。因此，我们需要为此事件添加一个回调。如果您有点迷茫，不要担心，只需按照以下步骤操作，您会发现它们如何连接在一起。

    call/add here = say 1, 2, 3

1. 我们需要添加一个回调。回调包含将在特定时间执行的代码。因此我们使用 `call/add` 命令和开关。
2. `here` 是我们的对象，我们所在的房间。
3. 一个等号。
4. 回调应连接到的事件名称。这里，事件是“say”。这意味着每当有人在房间里说话时，此回调将被执行。
5. 但我们添加了一个事件参数来指示在房间中说出的关键字应该执行我们的回调。否则，每当有人说话时，我们的回调都会被调用，无论说什么。这里我们限制，指示我们的回调应仅在所说的消息包含“1”、“2”或“3”时执行。

一个编辑器应该打开，邀请您输入要执行的 Python 代码。首先要记住的是阅读提供的文本（它可能包含重要信息），最重要的是，列出在此回调中可用的变量：

```
您可以在此事件中使用的变量：

    character: 在此房间中说话的角色。
    room: 连接到此事件的房间。
    message: 角色说的文本。

----------Line Editor [Callback say of Inside of an elevator]---------------------
01|
----------[l:01 w:000 c:0000]------------(:h for help)----------------------------
```

这很重要，以便知道我们可以在回调中使用哪些变量。让我们写一行代码，以确保我们的回调在我们期望时被调用：

```python
character.msg(f"You just said {message}.")
```

您可以在游戏中粘贴此行，然后键入 `:wq` 命令退出编辑器并保存您的修改。

让我们检查一下。尝试在房间里说“hello”。您应该会看到标准消息，但没有更多内容。现在尝试说“1”。在标准消息下方，您应该会看到：

    You just said 1.

您可以尝试一下。我们的回调仅在我们说“1”、“2”或“3”时被调用。这正是我们想要的。

让我们回到我们的代码编辑器并添加一些更有用的内容。

    call/edit here = say

> 注意这次我们使用了“edit”开关，因为回调已经存在，我们只想编辑它。

编辑器再次打开。让我们先清空它：

    :DD

并关闭自动缩进，这将帮助我们：

    :=

> 自动缩进是代码编辑器的一个有趣功能，但我们最好此时不要使用它，它会使复制/粘贴更复杂。

## 我们在电梯中的完整回调

现在是时候在游戏中真正编写我们的回调了。这里是一个小提醒：

1. 我们拥有三个房间和两个出口的所有 ID。
2. 当我们说“1”、“2”或“3”时，电梯应该移动到正确的房间，即更改出口。记住，我们已经有了出口，我们只需要更改它们的位置和目的地。

尝试自己编写此回调是个好主意，但如果您现在查看解决方案也没什么不好的。以下是您可以在代码编辑器中粘贴的可能代码：

```python
# 首先让我们定义一些常量
ELEVATOR = get(id=3)
FLOORS = {
    "1": get(id=2),
    "2": get(id=6),
    "3": get(id=7),
}
TO_EXIT = get(id=4)
BACK_EXIT = get(id=5)

# 现在我们检查电梯是否已经在此楼层
floor = FLOORS.get(message)
if floor is None:
    character.msg("Which floor do you want?")
elif TO_EXIT.location is floor:
    character.msg("The elevator already is at this floor.")
else:
    # 'floor' 包含电梯应该去的新房间
    room.msg_contents("The doors of the elevator close with a clank.")
    TO_EXIT.location = floor
    BACK_EXIT.destination = floor
    room.msg_contents("The doors of the elevator open to {floor}.",
            mapping=dict(floor=floor))
```

让我们回顾一下这个较长的回调：

1. 我们首先获取两个出口和三个楼层的对象。我们使用 `get()` 事件函数，这是获取对象的快捷方式。我们通常用它来检索具有 ID 的特定对象。我们将楼层放入一个字典中。字典的键是楼层号（作为字符串），值是房间对象。
2. 记住，`message` 变量包含在房间中说的话。所以是“1”、“2”或“3”。我们仍然需要检查它，因为如果角色在房间里说类似“1 2”的话，我们的回调将被执行。让我们确保她说的是楼层号。
3. 然后我们检查电梯是否已经在此楼层。注意，我们使用 `TO_EXIT.location`。`TO_EXIT` 包含我们的“北”出口，通往电梯内部。因此，它的 `location` 将是电梯当前所在的房间。
4. 如果楼层不同，让电梯“移动”，只需更改两个出口的位置和目的地。
   - `BACK_EXIT`（即“北”）应更改其位置。电梯不应通过我们的旧楼层进入。
   - `TO_EXIT`（即“南”，通往电梯的出口）应有不同的目的地。当我们走出电梯时，我们应该在新楼层，而不是旧楼层。

随意扩展此示例，更改消息，进行进一步检查。使用和实践是关键。

您可以像往常一样使用 `:wq` 退出编辑器并进行测试。

## 在回调中添加暂停

让我们改进我们的回调。值得添加的一件事是暂停：目前，当我们在电梯中说楼层号时，门会立即关闭和打开。最好有几秒钟的暂停。更合逻辑。

这是学习链式事件的好机会。链式事件非常有用，可以创建暂停。与我们迄今为止看到的事件相反，链式事件不会自动调用。它们必须由您调用，并且可以在一段时间后调用。

- 链式事件总是以 `"chain_X"` 命名。通常，X 是一个数字，但您可以为链式事件提供一个更明确的名称。
- 在我们的原始回调中，我们将在 15 秒后调用我们的链式事件。
- 我们还必须确保电梯尚未移动。

除此之外，链式事件可以像往常一样连接到回调。我们将在我们的电梯中创建一个链式事件，只包含在新楼层打开门所需的代码。

    call/add here = chain_1

回调被添加到 `"chain_1"` 事件，这是一个不会在发生某些事情时由系统自动调用的事件。在此事件中，您可以粘贴打开新楼层门的代码。您可以注意到一些差异：

```python
TO_EXIT.location = floor
TO_EXIT.destination = ELEVATOR
BACK_EXIT.location = ELEVATOR
BACK_EXIT.destination = floor
room.msg_contents("The doors of the elevator open to {floor}.",
        mapping=dict(floor=floor))
```

将此代码粘贴到编辑器中，然后使用 `:wq` 保存并退出编辑器。

现在让我们编辑“say”事件中的回调。我们将不得不稍微更改一下：

- 回调必须检查电梯是否已经在移动。
- 它必须在电梯移动时更改出口。
- 它必须调用我们定义的 `"chain_1"` 事件。它应该在 15 秒后调用。

让我们看看回调中的代码。

    call/edit here = say

删除当前代码并再次禁用自动缩进：

    :DD
    :=

然后您可以粘贴以下代码。注意与我们第一次尝试的区别：

```python
# 首先让我们定义一些常量
ELEVATOR = get(id=3)
FLOORS = {
    "1": get(id=2),
    "2": get(id=6),
    "3": get(id=7),
}
TO_EXIT = get(id=4)
BACK_EXIT = get(id=5)

# 现在我们检查电梯是否已经在此楼层
floor = FLOORS.get(message)
if floor is None:
    character.msg("Which floor do you want?")
elif BACK_EXIT.location is None:
    character.msg("The elevator is between floors.")
elif TO_EXIT.location is floor:
    character.msg("The elevator already is at this floor.")
else:
    # 'floor' 包含电梯应该去的新房间
    room.msg_contents("The doors of the elevator close with a clank.")
    TO_EXIT.location = None
    BACK_EXIT.location = None
    call_event(room, "chain_1", 15)
```

有什么变化？

1. 我们添加了一个小测试，以确保电梯尚未移动。如果是这样，`BACK_EXIT.location`（通往电梯外的“南”出口）应该是 `None`。我们将在电梯移动时移除出口。
2. 当门关闭时，我们将两个出口的 `location` 设置为 `None`。这将“移除”它们，但不会销毁它们。出口仍然存在，但它们不连接任何东西。如果您在电梯中说“2”并在电梯移动时环顾四周，您将看不到任何出口。
3. 我们没有立即打开门，而是调用 `call_event`。我们给它包含要调用的事件的对象（这里是我们的电梯），要调用的事件的名称（这里是“chain_1”）以及从现在起调用事件的秒数（这里是 `15`）。
4. 我们创建的 `chain_1` 回调包含“重新打开”电梯门的代码。也就是说，除了显示消息外，它还重置出口的 `location` 和 `destination`。

如果您尝试在电梯中说“3”，您应该会看到门关闭。环顾四周，您将看不到任何出口。然后，15 秒后，门应该打开，您可以离开电梯到达三楼。在电梯移动时，通往它的出口将无法进入。

> 注意：我们不会在我们的链式事件中再次定义变量，我们只是调用它们。当我们执行 `call_event` 时，我们当前变量的副本被放置在数据库中。当链式事件被调用时，这些变量将被恢复并再次可访问。

您可以使用 `call/tasks` 命令查看等待执行的任务。例如，在房间里说“2”，注意门关闭，然后输入 `call/tasks` 命令。您将在电梯中看到一个任务，等待调用 `chain_1` 事件。

## 更改出口消息

这里是事件的另一个不错的小功能：您可以修改单个出口的消息，而不影响其他出口。在这种情况下，当有人进入我们的电梯时，我们希望看到类似：“某人走进电梯。”对后退出口来说，类似的东西也不错。

在电梯内部，您可以查看通往外部（南）的出口上的可用事件。

    call south

您应该在此表中看到两行有趣的内容：

```
| msg_arrive       |   0 (0) | 自定义角色通过此出口到达时的消息。        |
| msg_leave        |   0 (0) | 自定义角色通过此出口离开时的消息。        |
```

因此，我们可以通过编辑“msg_leave”事件来更改其他人看到的角色离开时的消息。让我们这样做：

    call/add south = msg_leave

花时间阅读帮助。它为您提供了所有您需要的信息。我们需要更改“message”变量，并使用自定义映射（括号之间）来更改消息。我们给出了一个示例，让我们使用它。在代码编辑器中，您可以粘贴以下行：

```python
message = "{character} walks out of the elevator."
```

再次，输入 `:wq` 保存并退出编辑器。您可以创建一个新角色来查看它离开。

    charcreate A beggar
    tel #8 = here

（显然，如有必要，调整 ID。）

    py self.search("beggar").move_to(self.search("south"))

这是一种粗略的方式来强制我们的乞丐走出电梯，但它允许我们测试。您应该会看到：

    A beggar(#8) walks out of the elevator.

太好了！让我们对通往电梯内部的出口做同样的事情。跟随乞丐，然后编辑“north”的“msg_leave”：

    call/add north = msg_leave

```python
message = "{character} walks into the elevator."
```

再次，您可以强制我们的乞丐移动并查看我们刚刚设置的消息。此修改显然适用于这两个出口：自定义消息不会用于其他出口。由于我们在每层楼都使用相同的出口，因此无论电梯在哪一层，这都将可用，这非常不错！

## 教程常见问题

- **问：** 如果游戏在任务等待发生时重新加载或关闭，会发生什么？
- **答：** 如果您的游戏在任务暂停时重新加载（例如我们的电梯在楼层之间），当游戏再次可访问时，将调用任务（如有必要，使用新的时间差来考虑重新加载）。如果服务器关闭，显然任务不会被调用，但将在服务器再次启动时存储并执行。
- **问：** 我可以在我的回调中使用所有类型的变量吗？无论是否链式？
- **答：** 您可以在原始回调中使用您喜欢的每种变量类型。但是，如果您执行 `call_event`，由于您的变量存储在数据库中，它们将需要遵循持久属性的约束。例如，回调不会以这种方式存储。此变量在您的链式事件中将不可用。
- **问：** 当您说我可以将我的链式事件命名为“chain_1”、“chain_2”等以外的名称时，命名约定是什么？
- **答：** 链式事件的名称以 `"chain_"` 开头。这对您和系统都很有用。但在下划线之后，您可以给出一个更有用的名称，比如在我们的情况下是 `"chain_open_doors"`。
- **问：** 我必须暂停几秒钟才能调用链式事件吗？
- **答：** 不，您可以立即调用它。只需省略 `call_event` 的第三个参数（默认为 0，意味着链式事件将立即被调用）。这不会创建任务。
- **问：** 我可以让链式事件调用自己吗？
- **答：** 您可以。没有限制。只是要小心，一个调用自己的回调，特别是在没有延迟的情况下，可能是一个无限循环的好配方。然而，在某些情况下，让链式事件调用自己是有用的，例如每 X 秒执行相同的重复动作。
- **问：** 如果我需要多个电梯，我需要每次复制/粘贴这些回调吗？
- **答：** 不建议这样做。绝对有更好的方法来处理这种情况。其中之一是考虑将代码添加到源代码中。另一种可能性是调用具有预期行为的链式事件，这使得移植代码非常容易。链式事件的这一方面将在下一个教程中展示。
