# 理解颜色标签

本教程旨在澄清有关 Evennia 中颜色标签使用的混淆。

正确理解此主题需要先阅读 [Evennia 的颜色标签](../Concepts/Colors.md)。我们将通过示例来解释某些颜色标签背后意想不到（或明显不一致）行为的原因，正如在“颜色”页面中短暂提到的那样。

您只需访问一个运行中的 Evennia 实例并使用支持颜色的客户端即可完成本教程。提供的示例只是您可以在客户端中输入的命令。

## Evennia, ANSI 和 Xterm256

现代的 MUD 客户端都支持颜色；然而，所有客户端遵循的标准可以追溯到旧日的终端时代，当涉及到颜色时，我们处理的是 ANSI 和 Xterm256 标准。

Evennia 在后台透明地处理所有强制这些标准所需的代码——因此，如果用户连接到一个不支持颜色的客户端，或只支持 ANSI（16 种颜色），Evennia 将采取所有必要措施以确保输出在客户端侧看起来正确。

作为开发人员，您只需知道如何正确使用 MUD 中的颜色标签。您可能会添加颜色以帮助页面、描述、自动生成的文本等。

您可以自由地混合 ANSI 和 Xterm256 颜色标签，但应意识到一些陷阱。ANSI 和 Xterm256 在 Evennia 中共存而不冲突，但在许多方面，它们彼此“看不见”：特定于 ANSI 的颜色标签对 Xterm 定义的颜色没有效果，正如我们在这里将看到的。

## ANSI

ANSI 有一组 16 种颜色，准确地说：ANSI 有 8 种基本颜色，它们有 _暗_ 和 _亮_ 这两种风格——其中 _暗_ 是 _正常_ 的。颜色包括：红色、绿色、黄色、蓝色、品红色、青色、白色和黑色。正常情况下，黑色的亮版本通常被称为深灰色，而白色的暗版本通常被称为灰色。为了简单起见，它们将在这里被称为深色和亮色：亮/暗黑色，亮/暗白色。

MUD 客户端的默认颜色是正常（暗）白色在正常黑色上（即：灰色在黑色上）。

重要的是要理解，在 ANSI 标准中，亮色仅适用于文本（前景），而不适用于背景。Evennia 允许通过 Xterm256 绕过这个限制，但这样做会影响 ANSI 标签的行为，正如我们将在此看到的。

还需要记住，16 种 ANSI 颜色是一种约定，最后的用户总是可以自定义它们的外观——他们可能会决定让绿色显示为红色，深绿色显示为蓝色，等等。

## Xterm256

ANSI 的 16 种颜色对于处理简单的文本着色已经足够了。但当作者想要确保给定的颜色如她所愿显示时，她可能会选择依赖 Xterm256 颜色。

Xterm256 不依赖于命名颜色的调色板，而是通过它们的值来表示颜色。因此，红色可以是 `|[500`（亮且纯的红色），或者 `|[300`（深红色），以此类推。

## Evennia 中的 ANSI 颜色标签

> **注意**：为了便于阅读，示例中在颜色标签后包含额外的空格（例如：`|g green |b blue`）。这样做只是为了更容易看出标签与其上下文的分隔；在实际编程中，这不是一个好习惯。

让我们通过示例进行讨论。在您的 MUD 客户端中输入：

```
say Normal |* Negative
```

Evennia 应该将单词 "Normal" 正常输出（即：灰色在黑色上），并将 "Negative" 以反转的颜色输出（即：黑色在灰色上）。

这非常简单，`|*` ANSI *反转* 标签切换前景和背景——从现在开始，**FG** 和 **BG** 缩写将用于表示前景和背景。

但请记住，`|*` 已经切换了 *暗白* 和 *暗黑*。

现在试试这个：

```
say |w Bright white FG |* Negative
```

您会注意到 "Negative" 不再是黑色在白色上，而是深灰色在灰色上。为什么会这样？难道不是应该是黑色文本在白色背景上吗？这里发生了两件事情。

如前所述，ANSI 只有 8 种基本颜色，暗色。亮色是通过强调基本/暗/正常颜色来实现的，并且它们仅适用于前景。

在这里，当我们用 `|w` 设置亮白前景时，Evennia 将其转换为亮白的 ANSI 序列（开启高亮 + 白色前景）。在 Evennia 的颜色标签中，这就像我们输入：

```
say |h|!W Bright white FG |* Negative
```

此外，Highlight-On 属性（仅适用于背景！）在前景/背景切换之后被保留下来，这就是为什么我们看到黑色变成深灰色：高亮使其成为 *亮黑色*（即：深灰色）。

至于背景也是灰色，这很正常——即：您正在看到 *正常白色*（即：暗白色 = 灰色）。请记住，由于没有亮背景色，因此 ANSI `|*` 标签会将任何前景颜色转换为其正常/暗版本。因此，这里前景的亮白色变成了背景的暗白色！实际上，它一直都是正常/暗白色，只是由于在幕后存在高亮标签而在前景中看起来是亮色。

现在尝试一些颜色：

```
say |m |[G Bright Magenta on Dark Green |* Negative
```

同样，背景保持暗色是因为 ANSI 规则，而前景因为隐含的 `|h` 保持明亮。

现在，让我们看看如果我们设置一个亮背景颜色然后进行反转会发生什么——是的，Evennia 允许我们这样做，即使这不符合 ANSI 预期。

```
say |[b Dark White on Bright Blue |* Negative
```

在颜色反转之前，背景确实显示为亮蓝色，并且在反转之后（如预期）它是 *暗白色*（灰色）。背景的亮蓝色在反转过程中幸存下来，并给我们一个亮蓝色前景。

这种行为有点棘手，并不像它看起来那么简单。

如果反转是纯 ANSI，亮蓝色本应被视为正常蓝色，并且在前景中应该转换为正常的蓝色（毕竟，没有高亮）。事实上，这种颜色根本不是亮蓝色，只是其 Xterm 版本！

为了证明这一点，输入：

```
say |[b Dark White on Bright Blue |* Negative |H un-bright
```

`|H` Highlight-Off 标签应该将最后一个单词变成 *暗蓝色*；但它没有这样做，因为它无法做到：为了强制施加非 ANSI 亮背景，Evennia 切换到了 Xterm，而 Xterm 对象不受 ANSI 标签的影响！

因此，我们正在接触到所有与 Evennia 中颜色标签相关的混淆和可能的奇异行为的核心：除 Evennia 的 ANSI/Xterm 转换外，这两个系统彼此独立且透明。

上面的亮蓝色只是 ANSI 标准蓝色的 Xterm 表示。尝试更改客户端的默认设置，以使蓝色显示为其他颜色，您就会意识到当 Evennia 发送真实的 ANSI 颜色时（根据您的设置显示出来）与当它发送 Xterm 表示的颜色时（其显示总是如 Evennia 定义的那样）之间的区别。

您必须记住，Xterm 背景或前景颜色的存在可能会影响文本中标签的工作方式。例如：

```
say |[b Bright Blue BG |* Negative |!Y Dark Yellow |h not bright
```

在这里，`|h` 标签不再影响前景颜色。虽然它通过 `|!` 标签被更改，ANSI 系统由于干扰 Xterm 颜色（亮蓝色背景，然后通过 `|*` 移动到前景）而失调。

所有意外的 ANSI 行为都是混合 Xterm 颜色（无论是故意还是通过亮背景颜色）造成的。`|n` 标签将恢复所有内容，ANSI 标签将再次正常响应。因此，最终只需谨慎使用 Xterm 颜色或亮背景，并避免在未将所有内容规范化（`|n`）的情况下与 ANSI 标签进行随意混合。

试试这个：

```
say |[b Bright Blue BG |* Negative |!R Red FG
```

然后：

```
say |[B Dark Blue BG |* Negative |!R Red BG
```

在第二个示例中，`|!` 改变背景颜色而不是前景！事实上，奇异的行为是前一个示例，而不是后者。当您使用 `|*` 反转前景和背景时，您实际上是在反转它们的引用。这就是为什么最后一个示例（具有正常/暗背景！）允许 `|!` 改变背景颜色。在第一个示例中，再次是由于 Xterm 颜色（亮蓝色背景）的存在改变了默认行为。

再试这个：

```
say Normal |* Negative |!R Red BG
```

这是正常行为，正如您所看到的，它允许在前景和背景反转后用 `|!` 更改背景颜色。

只要您理解 ANSI 的工作方式，就应该能够处理颜色标签，避免 Xterm-ANSI 混合的陷阱。

最后一个示例：

```
say Normal |* Negative |* still Negative
```

显示 `|*` 只能在一行中工作一次，并且在再次使用时不会（也不应该！）还原。如果在调用 `|n` 标签之前不再有效。这就是它的工作原理。

ANSI 根据简单的状态机制运行，理解使用 `|n` 标签重置的积极效果是很重要的，而不是在某种意义上试图将其推向极限。
