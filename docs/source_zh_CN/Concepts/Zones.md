# 区域

Evennia 推荐使用 [标签](../Components/Tags.md) 来创建区域和其他分组。

假设你在一个美丽的大森林 MUD 中创建了一个名为 *Meadow* 的房间。这一切都很美好，但如果你在森林的另一端也想要一个 *Meadow*，作为游戏创建者，这可能会引起各种混乱。例如，传送到 *Meadow* 时会收到警告，提示有两个 *Meadow*，需要选择其中一个。虽然可以选择去 `2-meadow`，但除非仔细检查，否则无法确定哪个位于森林的魔法部分，哪个不在。

另一个问题是如果你想将房间按地理区域分组。假设森林的“普通”部分应该与魔法部分有不同的天气模式。或者可能有一种魔法干扰回荡在所有魔法森林房间中。在这种情况下，能够简单地找到所有“魔法”房间以便发送消息会很方便。

## Evennia 中的区域

*区域* 试图通过全局位置来分隔房间。在我们的例子中，我们可以将森林分为两部分——魔法部分和非魔法部分。每个部分都有一个 *Meadow*，并且每个部分的房间都应该易于检索。

许多 MUD 代码库将区域硬编码为引擎和数据库的一部分。Evennia 没有做这样的区分。

Evennia 中的所有对象都可以拥有任意数量的 [标签](../Components/Tags.md)。标签是附加到对象上的简短标签，它们使得检索对象组变得非常容易。一个对象可以拥有任意数量的不同标签。因此，我们可以将相关标签附加到我们的森林：

```python
forestobj.tags.add("magicalforest", category="zone")
```

你可以手动添加这个标签，或者在创建过程中以某种方式自动添加（你可能需要修改 `dig` 命令）。你还可以在构建过程中使用默认的 `tag` 命令：

```
tag forestobj = magicalforest : zone
```

从此以后，你可以轻松检索具有给定标签的对象：

```python
import evennia
rooms = evennia.search_tag("magicalforest", category="zone")
```

## 使用类型类和继承进行区域划分

上述的标签或别名系统并没有在功能上区分魔法森林房间和普通房间——它们只是标记对象以便快速检索的任意方式。任何功能上的差异必须通过 [类型类](../Components/Typeclasses.md) 来表达。

当然，实现区域的另一种方法是让一个区域中的所有房间/对象继承自给定的类型类父类，然后将搜索限制为继承自该父类的对象。效果类似，但需要扩展搜索功能以正确搜索继承树。
